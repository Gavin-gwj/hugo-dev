[{"content":"🐳 Docker 入门学习笔记（小白也能看懂！） 🚀 什么是 Docker？ Docker 就像一个“应用装在盒子里”的系统，它可以让我们在任何地方快速运行一个“打包好的应用环境”。\n容器（Container）：装着软件和运行环境的盒子 镜像（Image）：这个盒子的“蓝图”，可以无限复制 宿主机（Host）：你电脑/服务器，就是装盒子的地方 🛠 Docker 常用命令一览 命令 说明 docker ps 查看正在运行的容器 docker ps -a 查看所有容器（包括已停止的） docker images 查看已有镜像 docker run 创建并运行容器 docker start 容器名/ID 启动一个停止的容器 docker stop 容器名/ID 停止容器 docker rm 容器名/ID 删除容器 docker rmi 镜像名/ID 删除镜像 📦 Docker 数据卷（Volume） ✅ 什么是数据卷？ Docker 容器里的数据默认是临时的，你一删容器数据就没了。\n数据卷就是 Docker 的“存档系统”，数据可以长期保存。\n🎮 打比方： 容器就像是你玩的游戏 数据卷就像你保存进度的U盘 不挂数据卷 = 玩了也白玩，关机就全没了！ 🧱 如何使用数据卷？ ✅ 创建并挂载数据卷： 1 2 3 4 5 6 docker run -d \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=123 \\ -p 3306:3306 \\ -v mysql-data:/var/lib/mysql \\ mysql -v 卷名:容器内部路径\n上面例子就是：把容器的 /var/lib/mysql 存储在宿主机的 mysql-data 卷里。\n🔍 查看和管理卷 1 2 3 4 docker volume ls # 查看有哪些卷 docker volume inspect 卷名 # 查看卷详情（比如路径） docker volume rm 卷名 # 删除某个卷 docker volume prune # 删除所有没用的卷 ⚠️ volume prune 是大扫除，用前请慎重！\n⚠️ 常见错误：端口占用 如果你运行容器时报这个错：\n1 Error: listen tcp4 0.0.0.0:3306: bind: address already in use 🎯 说明： 👉 你要映射的端口（比如 3306）已经被别的程序/容器占用了！\n🛠 解决方法： 找到谁占用了端口：\n1 lsof -i :3306 杀掉那个进程：\n1 kill -9 进程ID 或者换一个端口映射：\n1 -p 13306:3306 # 把宿主机的13306映射到容器的3306 🌊 小结 名词 通俗理解 容器 装着应用的“盒子” 镜像 造盒子的“模具” 卷（volume） 用来保存“盒子数据”的U盘 -v 参数 把容器里的数据保存出来 -p 参数 把容器里的端口映射出来 -e 参数 给容器传环境变量，比如数据库密码 💡 推荐学习方式 多用 docker run 搞实验\n数据重要的容器 一定要挂数据卷！\n不怕错，错了就 docker rm 删除重来！\n🎉 恭喜你，已经比大多数人更懂 Docker 的基础啦！继续冲！\n","date":"2025-08-05T15:32:51+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/docker-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82/","title":"Docker 入门学习笔记（小白也能看懂！）"},{"content":"@Component 与 @Bean 的区别：Spring核心注解学习笔记 在 Spring 框架中，@Component 和 @Bean 是两个最常用也是最核心的注解，它们都用于将对象（Bean）注册到 Spring IOC 容器中，从而实现依赖注入。然而，它们在使用场景和作用方式上有着本质的区别。\n一、核心概念速览 @Component:\n作用对象: 类（Class）\n核心思想: 自动扫描（Component Scanning）。告诉 Spring：“这是一个需要被管理的组件，请在扫描时找到我，并为我创建一个实例。”\n属于: \u0026ldquo;Stereotype\u0026rdquo;（构造型）注解，它还有几个常用的衍生注解：\n@Service: 用于标注业务逻辑层的组件。\n@Repository: 用于标注数据访问层（DAO）的组件。\n@Controller / @RestController: 用于标注Web控制层的组件。\n@Bean:\n作用对象: 方法（Method）\n核心思想: 显式声明。在一个用 @Configuration 注解的类中，通过一个方法来创建一个对象，并用 @Bean 告诉 Spring：“这个方法返回的对象需要被注册到容器中。”\n灵活性: 提供了更强的灵活性和自定义能力。\n二、关键区别对比 特性 @Component @Bean 注解位置 类上 方法上 (该方法必须在@Configuration或@Component类中) 控制权 控制权在开发者 (将注解加在自己编写的类上) 控制权在配置类 (可以在方法中对第三方库的类进行实例化和配置) 使用场景 自动配置：用于我们自己开发的类，实现自动扫描和装配。 手动配置：用于将第三方库中的类、或者需要复杂初始化逻辑的类注入到容器中。 自定义 较弱，Spring 自动处理实例化。 非常灵活，可以在方法体中编写任意的初始化逻辑，再返回最终的对象实例。 耦合度 被注解的类与 Spring 框架有一定的耦合。 将 Bean 的创建逻辑集中在配置类中，与业务类本身解耦。 生命周期 由 Spring 容器通过组件扫描自动管理。 可以在@Bean注解中指定initMethod和destroyMethod来管理生命周期回调。 三、使用场景（Use Cases） 通过具体的例子来理解何时使用它们是最好的方式。\n场景一：使用 @Component 假设你正在开发一个用户服务，你自己编写了 UserService 和 UserRepository。\n步骤:\n在你的类上加上 @Service (它是 @Component 的一种)。\n确保你的 Spring Boot 主启动类或配置类上有 @ComponentScan (在 Spring Boot 中通常是默认启用的)。\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 数据访问层 @Repository // @Repository 也是一种 @Component public class UserRepository { public User findById(Long id) { // ... 查询数据库的逻辑 ... return new User(); } } // 业务逻辑层 @Service // @Service 是一种 @Component public class UserServiceImpl implements UserService { private final UserRepository userRepository; // 使用构造函数注入，这是推荐的方式 @Autowired public UserServiceImpl(UserRepository userRepository) { this.userRepository = userRepository; } @Override public User getUserById(Long id) { return userRepository.findById(id); } } 总结: 对于我们自己项目中的类，使用 @Component 及其衍生注解是最直接、最常见的方式。Spring 会自动扫描并创建它们的实例。\n场景二：使用 @Bean 现在，假设你的项目需要使用一个第三方的库，比如一个 DataSource（数据源）或者一个 RestTemplate（用于发起HTTP请求）。你无法修改这些类的源代码去给它们加上 @Component 注解。这时，@Bean 就派上用场了。\n步骤:\n创建一个配置类，并用 @Configuration 注解它。\n在类中创建一个方法，这个方法返回你需要被 Spring管理的对象实例。\n在该方法上加上 @Bean 注解。\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class AppConfig { // 场景1: 注入一个第三方库的类 @Bean public RestTemplate restTemplate() { // 在这里可以进行各种自定义配置 // 比如设置超时时间、消息转换器等 return new RestTemplate(); } // 场景2: 需要复杂的初始化逻辑 @Bean(name = \u0026#34;customUser\u0026#34;) // 也可以自定义 Bean 的名字 public User createCustomUser() { User user = new User(); user.setName(\u0026#34;我是通过@Bean创建的\u0026#34;); user.setRole(\u0026#34;ADMIN\u0026#34;); // ... 其他复杂的初始化设置 ... return user; } } 总结: 当你想要将一个无法直接修改源码的类（例如来自第三方JAR包的类）的实例交给 Spring 管理时，或者当一个对象的创建过程比较复杂，需要一些自定义的初始化逻辑时，@Bean 是最佳选择。\n四、核心总结 @Component 是 “自动挡”：你只需要在自己的类上标记一下，Spring 会帮你搞定剩下的。适用于管理自己项目中的组件。\n@Bean 是 “手动挡”：你需要在一个配置类中，亲手通过一个方法来创建和配置对象。适用于管理第三方组件或需要复杂初始化的对象。\n简单记：管自己的类，用 @Component；管别人的类，用 @Bean。\n面试官问：@Component 和 @Bean 有什么区别？该怎么回答 面试时，回答这个问题的关键在于结构清晰、由浅入深、并结合实际场景。下面是一个推荐的回答结构和内容。\n第一步：给出核心摘要（一句话总结） 你应该先用一句话概括出最核心的区别，这能立刻向面试官展示你对概念的清晰理解。\n面试官您好，@Component 和 @Bean 最核心的区别在于它们的使用方式和目标对象不同。@Component 是一个类级别的注解，用于Spring的自动扫描和装配；而 @Bean 是一个方法级别的注解，用于在配置类中显式地声明和定义一个Bean。\n第二步：深入阐述关键不同点（展开对比） 在给出摘要后，从几个关键维度展开详细对比，展示你知识的深度。\n1. 注解的目标不同\n@Component：直接用在类上。它告诉 Spring：“请扫描这个类，并为我创建一个实例放入容器中。” 它是一种“声明式”的组件，我们只需要声明，具体创建由 Spring 完成。\n@Bean：用在方法上。这个方法必须定义在一个由 @Configuration 或 @Component 注解的类中。它告诉 Spring：“请执行这个方法，并将该方法返回的对象实例放入容器中。”\n2. 控制粒度和来源不同\n@Component 主要用于我们自己开发的类。我们对这些类有完全的控制权，可以直接在类定义上添加注解。这是一种“自动化”的配置方式。比如我们自己写的 UserService、OrderController 等。\nJava\n1 2 3 4 5 // 我们自己写的类，有源码控制权 @Service // @Service 是 @Component 的一种特化 public class MyUserService { // ... } @Bean 主要用于将第三方库中的类或需要复杂初始化逻辑的类纳入 Spring 管理。因为我们无法修改第三方库的源码去添加 @Component 注解，所以只能在我们的配置类中，通过一个方法来创建它的实例，并用 @Bean 声明。这提供了更强的灵活性和控制权。\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class AppConfig { // 我们无法修改 RestTemplate 的源码，所以用 @Bean @Bean public RestTemplate restTemplate() { // 在这里可以进行非常灵活的自定义配置 RestTemplate template = new RestTemplate(); template.setConnectTimeout(Duration.ofSeconds(5)); return template; } } 3. 使用场景总结\n何时使用 @Component？\n当你创建的是自己项目中的业务组件时（如@Controller, @Service, @Repository）。\n当这个组件的创建不需要复杂的配置逻辑时。\n追求自动化配置和约定大于配置的开发模式时。\n何时使用 @Bean？\n当你需要将一个第三方库提供的对象（如 DataSource, RestTemplate, JedisPool）注册为 Bean 时。\n当一个对象的实例化过程非常复杂，需要在创建前执行一些前置配置或逻辑时。\n当你需要根据不同的条件创建不同的 Bean 实例时（例如结合 @Profile 或 @Conditional 注解）。\n第三步：用一个生动的比喻结尾（加深印象） 最后，用一个简单的比喻来总结，能让你的回答更生动，更容易被记住。\n所以，您可以把 @Component 理解为“自动挡”汽车，我们只需要挂上挡（加上注解），车（Spring）就会自动行驶（创建Bean）。而 @Bean 则更像是“手动挡”汽车，我们需要自己踩离合、挂挡、给油（在方法中编写创建和配置逻辑），控制更加精细和灵活。\n简单来说，就是一句话：我们自己代码里的类用 @Component，引入的外部依赖或需要复杂配置的用 @Bean。\n","date":"2025-07-04T20:07:58+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spring%E7%AF%87-@component-%E4%B8%8E-@bean-%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"Spring篇-@Component 与 @Bean 的区别"},{"content":"对于初学者来说，“对象属性拷贝”这个概念一开始可能会有点抽象，特别是和 DTO (Data Transfer Object) 一起出现时。\n别担心，这个概念本身并不复杂。它其实就是解决一个很常见的编程问题：如何方便、安全地把数据从一个“篮子”（对象A）装到另一个“篮子”（对象B）里。\n📝 关于「对象属性拷贝」的学习笔记 你好！很高兴你开始学习 DTO 相关的知识。在深入 DTO 之前，我们必须先掌握一个基础且非常实用的技能：对象属性拷贝 (Object Property Copying)。\n📌 1. 为什么需要这东西？从一个故事说起 想象一下，你正在开发一个网站。后端程序从数据库里查询出了一个用户（User）的完整信息。这个 User 对象可能长这样：\nJavaScript\n1 2 3 4 5 6 7 8 9 // 这是一个代表数据库里用户信息的对象 (我们称之为“实体” Entity) let userFromDB = { id: 123, username: \u0026#34;zhangsan\u0026#34;, password: \u0026#34;a_very_long_and_secret_password_hash\u0026#34;, // 密码的哈希值，非常敏感！ email: \u0026#34;zhangsan@example.com\u0026#34;, createTime: \u0026#34;2023-10-27T10:00:00Z\u0026#34;, role: \u0026#34;admin\u0026#34; }; 现在，前端页面需要显示用户的基本信息（ID、用户名、邮箱）。我们是不是应该直接把 userFromDB 这个对象整个发给前端呢？\n绝对不行！ 🙅‍♂️\n如果我们直接发送，就会把 password（密码）和 role（角色）这种敏感信息也泄露给前端了。这是非常危险的。\n所以，我们需要一个“中间人”，一个专门用来在网络上传输数据的“小包裹”。这个小包裹就是 DTO (Data Transfer Object)。它只包含前端需要的数据：\nJavaScript\n1 2 3 4 5 6 // 这是一个专门用于传输的用户信息对象 (DTO) let userForFrontEnd = { id: 0, // 准备接收数据 username: \u0026#34;\u0026#34;, // 准备接收数据 email: \u0026#34;\u0026#34; // 准备接收数据 }; 那么问题来了：如何把 userFromDB 里的 id, username, email 的值，填到 userForFrontEnd 这个新对象里呢？\n这就是“对象属性拷贝”大显身手的时刻！\n核心思想：对象属性拷贝，就是将一个源对象 (Source Object) 的属性值，复制到另一个目标对象 (Target Object) 的同名属性中。\n💡 2. 怎么拷贝？从手动到自动 2.1 最笨拙的方法：手动拷贝 最直观的方法，就是一个一个地赋值。\nJavaScript\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 源对象 let userFromDB = { id: 123, username: \u0026#34;zhangsan\u0026#34;, password: \u0026#34;...\u0026#34;, email: \u0026#34;zhangsan@example.com\u0026#34; }; // 目标对象 let userForFrontEnd = {}; // 创建一个空对象 // 手动一个一个地拷贝 userForFrontEnd.id = userFromDB.id; // 把 123 拷贝过去 userForFrontEnd.username = userFromDB.username; // 把 \u0026#34;zhangsan\u0026#34; 拷贝过去 userForFrontEnd.email = userFromDB.email; // 把 \u0026#34;zhangsan@example.com\u0026#34; 拷贝过去 // 现在，userForFrontEnd 就是 { id: 123, username: \u0026#34;zhangsan\u0026#34;, email: \u0026#34;zhangsan@example.com\u0026#34; } // 它很“干净”，不包含任何敏感信息，可以安全地发给前端了。 优点：\n非常清晰，一目了然。\n可以精确控制拷贝哪些属性，忽略不需要的属性（比如 password）。\n缺点：\n如果对象有50个属性，手动写50行代码会非常繁琐且容易出错。 2.2 聪明一点的方法：使用工具库 几乎所有的编程语言都提供了简化这个过程的工具。在 Java 中有 BeanUtils.copyProperties()，在 JavaScript 中有 Object.assign() 或扩展运算符 ...。它们可以自动拷贝所有同名的属性。\n以 JavaScript 的 Object.assign() 为例：\nJavaScript\n1 2 3 4 5 6 7 8 9 10 11 let source = { a: 1, b: 2 }; let target = { b: 3, c: 4 }; // Object.assign(目标, 源1, 源2, ...) // 它会把所有源对象的属性拷贝到目标对象，如果属性名相同，后面的会覆盖前面的。 Object.assign(target, source); // 结果是什么？ // 1. source 的 a:1 被拷贝到 target，target 变成 { b: 3, c: 4, a: 1 } // 2. source 的 b:2 被拷贝到 target，覆盖了原来的 b:3，target 最终变成 { c: 4, a: 1, b: 2 } console.log(target); // 输出 {c: 4, a: 1, b: 2} 用这个方法来解决我们最初的问题：\n这种工具非常适合将一个简单的字典（比如前端发来的请求体）的属性拷贝到一个对象上。但是，从 Entity 拷贝到 DTO 时，由于我们想忽略某些属性，直接使用 Object.assign 仍然会把 password 等敏感属性拷贝过去。\n因此，更专业的做法是使用专门的 Mapper (映射器) 库，例如 Java 的 MapStruct、ModelMapper，或者 .NET 的 AutoMapper。这些库可以让你配置映射规则，比如：“把 User 拷贝到 UserDTO 时，请忽略 password 字段”。\n⚠️ 3. 重要的区别：浅拷贝 vs. 深拷贝 这是学习属性拷贝时必须理解的一个关键点，也是面试中经常被问到的问题。\n3.1 浅拷贝 (Shallow Copy) 想象一下，你的对象里有一个属性，它的值本身也是一个对象。\nJavaScript\n1 2 3 4 5 6 7 8 9 10 let user = { name: \u0026#34;lisi\u0026#34;, address: { // address 是一个嵌套的对象 city: \u0026#34;Beijing\u0026#34;, street: \u0026#34;Wangfujing\u0026#34; } }; let copiedUser = {}; Object.assign(copiedUser, user); // 这就是一种浅拷贝 浅拷贝的特点：\n它只拷贝对象的第一层属性。\n如果某个属性的值是一个基础类型（如数字、字符串），它会拷贝这个值。\n如果某个属性的值是一个引用类型（如另一个对象、数组），它只会拷贝这个引用的“地址”，而不是创建一个新的对象。\n后果是什么？\nuser 和 copiedUser 的 address 属性指向的是同一个内存地址里的同一个 { city: \u0026quot;Beijing\u0026quot;, ... } 对象。\n如果你修改 copiedUser 的地址，user 的地址也会跟着变！\nJavaScript\n1 2 3 copiedUser.address.city = \u0026#34;Shanghai\u0026#34;; // 修改拷贝后对象的城市 console.log(user.address.city); // 输出 \u0026#34;Shanghai\u0026#34;！ 😱 **原始对象被意外修改了！** 适用场景：当你的对象结构很简单，没有嵌套的对象或数组时，浅拷贝速度快，效率高，完全够用。我们之前 User 到 UserDTO 的转换，就属于这种情况。\n3.2 深拷贝 (Deep Copy) 深拷贝会彻底地、递归地复制一个对象的所有层级。\nJavaScript\n1 2 // (伪代码，不同语言实现方式不同) let deepCopiedUser = deepCopy(user); 深拷贝的特点：\n它会创建一个全新的、一模一样但完全独立的对象。\n如果遇到嵌套的对象，它会为这个嵌套对象也创建一个全新的副本。\n后果是什么？\nuser 和 deepCopiedUser 内部的所有部分都是独立的，互不影响。\n如果你再次修改地址：\nJavaScript\n1 2 3 deepCopiedUser.address.city = \u0026#34;Shenzhen\u0026#34;; // 修改深拷贝后对象的城市 console.log(user.address.city); // 输出 \u0026#34;Beijing\u0026#34;。 ✅ **原始对象安然无恙！** 适用场景：当你需要一个对象的完整、独立的副本，并且不希望任何对副本的修改影响到原始对象时，就必须使用深拷贝。这在复杂的状态管理（如前端框架 Vuex/Redux）或需要历史记录功能时非常重要。\n✅ 总结与回顾 是什么：对象属性拷贝就是把一个对象（源）的属性值，复制到另一个对象（目标）上。\n为什么用：最常见的场景是为了构建 DTO。从包含敏感信息的完整对象（Entity）中，只挑选出安全、必需的属性，拷贝到一个新的 DTO 对象中，用于网络传输或视图展示。\n怎么做：\n手动拷贝：简单、可控，但繁琐。\n工具/库：如 Object.assign，可以自动拷贝同名属性。更专业的有 Mapper 库，可以配置复杂的映射规则。\n关键区别：\n浅拷贝 (Shallow Copy)：只拷贝第一层，速度快。嵌套的对象共享同一个引用，修改一个会影响另一个。\n深拷贝 (Deep Copy)：递归拷贝所有层，生成完全独立的新对象，互不干扰，但性能开销更大。\n记住，它不是一个孤立的技术，而是编程中为了实现数据隔离、安全和封装而广泛使用的一种基本模式。\n","date":"2025-07-03T16:30:57+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8B%B7%E8%B4%9D/","title":"什么是对象的属性拷贝"},{"content":"Spring Cache 入门笔记 1. 什么是 Spring Cache？ 想象一下，你的应用程序有一个方法，需要从数据库查询一些不经常变化的数据，比如商品分类。每次用户请求这个数据，你的代码都会执行一次数据库查询，如果访问量很大，这会对数据库造成巨大的压力，并且响应速度也会变慢。\nSpring Cache 就是为了解决这类问题而生的。\n它是一个基于注解的缓存解决方案，能够将方法的运行结果存储起来（通常是存储在内存或像 Redis 这样的高速缓存数据库中）。当下次用相同的参数再次调用这个方法时，Spring Cache 会直接返回之前存储的结果，而不会再执行方法体内的代码（例如，不会再去查数据库）。\n核心思想： 用一个简单的注解，为你的 Java 方法添加缓存能力，从而提高应用性能和响应速度。\n2. 核心概念 在使用 Spring Cache 之前，你需要理解几个关键概念：\n概念 (英文) 概念 (中文) 解释 Cache 缓存 一个存储键值对（Key-Value）的容器。在 Spring Cache 中，它是一个逻辑上的概念，可以对应一个具体的缓存实现（如一个 ConcurrentMap，一个 Redis Hash 等）。 CacheManager 缓存管理器 顾名思义，它是用来管理多个 Cache 实例的。你可以通过它来获取、创建或删除 Cache。Spring Boot 会根据你的依赖和配置自动配置一个 CacheManager。 @EnableCaching 开启缓存 这是一个开关。在你的 Spring Boot 主启动类或任何配置类上添加这个注解，就代表 \u0026ldquo;我要开始使用 Spring Cache 的功能了！\u0026quot;。 缓存注解 缓存注解 Spring Cache 的精髓所在。通过在方法上添加不同的注解（如 @Cacheable, @CachePut, @CacheEvict），来告诉 Spring 如何操作缓存。 导出到 Google 表格\n3. 最核心的三个注解 掌握了下面这三个注解，你就掌握了 Spring Cache 80% 的用法。\n3.1 @Cacheable：查询缓存，有则返回，无则执行并缓存 这是最常用，也是最重要的一个注解。它的作用是：\n在方法执行前，Spring 会根据方法的参数生成一个 Key。\n用这个 Key 去 Cache 中查找。\n如果找到了：直接返回找到的 Value，方法体内的代码完全不会执行。\n如果没有找到：执行方法体内的代码，获取返回值。然后将 Key-返回值 这个键值对存入 Cache 中，最后再返回这个值。\n使用场景：查询操作，尤其是不经常变化的数据查询（比如，根据 ID 查询用户信息、查询商品详情等）。\n示例代码：\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService { // 模拟数据库查询 @Override @Cacheable(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public User findUserById(Long id) { System.out.println(\u0026#34;正在从数据库中查询用户，ID: \u0026#34; + id); // 实际的数据库查询逻辑... return new User(id, \u0026#34;张三\u0026#34;); } } 代码解释：\n@Cacheable(cacheNames = \u0026quot;users\u0026quot;, key = \u0026quot;#id\u0026quot;)\ncacheNames = \u0026quot;users\u0026quot;: 指定了要使用的 Cache 的名字叫做 \u0026ldquo;users\u0026rdquo;。你可以把它想象成数据库中的一张表名。你可以指定多个 cacheNames，如 {\u0026quot;users\u0026quot;, \u0026quot;customers\u0026quot;}。\nkey = \u0026quot;#id\u0026quot;: 这是缓存的 Key。这里使用了 Spring Expression Language (SpEL)。#id 表示使用方法参数中名为 id 的值作为 Key。\n第一次调用 findUserById(1L) 时，控制台会打印 \u0026ldquo;正在从数据库中查询用户\u0026hellip;\u0026quot;。\n第二次调用 findUserById(1L) 时，控制台不会有任何输出，方法会直接返回上次缓存的结果。\n调用 findUserById(2L) 时，因为 Key 不同，所以会再次查询数据库。\n3.2 @CachePut：更新缓存，每次都执行，并刷新缓存 有时候我们希望更新数据，并确保缓存中的数据也是最新的。这时就用 @CachePut。\n它的作用是：\n不管缓存中有没有，方法体内的代码总是会执行。\n方法执行成功后，将生成的 Key-返回值 存入 Cache 中。如果该 Key 已存在，则会覆盖原来的值。\n使用场景：更新操作。比如，更新了用户信息后，希望缓存中的用户信息也同步更新。\n示例代码：\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.cache.annotation.CachePut; import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService { @Override @CachePut(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;) public User updateUser(User user) { System.out.println(\u0026#34;正在更新数据库中的用户，ID: \u0026#34; + user.getId()); // 实际的数据库更新逻辑... // 必须返回更新后的对象，这个返回值会被放入缓存 return user; } } 代码解释：\n@CachePut(cacheNames = \u0026quot;users\u0026quot;, key = \u0026quot;#user.id\u0026quot;)\nkey = \u0026quot;#user.id\u0026quot;: 使用传入的 user 对象的 id 属性作为 Key。\n每次调用 updateUser(new User(1L, \u0026quot;李四\u0026quot;)) 时，控制台总是会打印 \u0026ldquo;正在更新数据库中的用户\u0026hellip;\u0026quot;。\n执行完毕后，users 缓存中 Key 为 1L 的值会被更新为返回的 User 对象。这样下次 findUserById(1L) 就能获取到最新的用户信息了。\n3.3 @CacheEvict：删除缓存 当数据被删除时，我们也应该把缓存中对应的数据清理掉，避免用户获取到脏数据。\n它的作用是：根据指定的 Key，从 Cache 中删除对应的条目。\n使用场景：删除操作。\n示例代码：\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.cache.annotation.CacheEvict; import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService { @Override @CacheEvict(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;) public void deleteUser(Long id) { System.out.println(\u0026#34;正在从数据库中删除用户，ID: \u0026#34; + id); // 实际的数据库删除逻辑... } } 代码解释：\n@CacheEvict(cacheNames = \u0026quot;users\u0026quot;, key = \u0026quot;#id\u0026quot;)\n调用 deleteUser(1L) 后，Spring Cache 会将 users 缓存中 Key 为 1L 的数据删除。\n一个有用的属性：allEntries = true。如果设置为 true，它会清空整个 \u0026quot;users\u0026quot; 缓存，而不是只删除某个 Key。例如 @CacheEvict(cacheNames = \u0026quot;users\u0026quot;, allEntries = true)。\n4. 如何在 Spring Boot 项目中使用 在 Spring Boot 中使用 Spring Cache 非常简单，只需三步。\n第一步：添加依赖\n在你的 pom.xml 文件中，添加 Spring Cache 的启动器依赖。\nXML\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 第二步：开启缓存功能\n在你的主启动类上添加 @EnableCaching 注解。\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching // 开启缓存功能 public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 第三步：在方法上使用注解\n就像上面的例子一样，在你的 Service 方法上添加 @Cacheable, @CachePut, @CacheEvict 注解即可。\n默认的缓存是什么？\n如果你只完成了上面三步，Spring Boot 默认会使用 ConcurrentHashMap作为缓存。这意味着缓存是存储在应用程序的内存中的。这对于单个应用实例的简单场景是够用的，但有以下缺点：\n应用重启后缓存会全部丢失。\n在分布式或集群环境下，每个应用实例都维护自己的缓存，无法共享。\n因此，在生产环境中，我们通常会集成专业的缓存中间件，如 Redis。\n5. 集成 Redis作为缓存 将 Spring Cache 的底层实现替换为 Redis 非常流行且简单。\n第一步：添加 Redis 依赖\n在 pom.xml 中添加 spring-boot-starter-data-redis。\nXML\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 第二步：配置 Redis 连接\n在 application.properties 或 application.yml 文件中配置 Redis 的地址、端口等信息。\napplication.properties 示例:\nProperties\n1 2 3 4 5 6 # Redis 服务器地址 spring.redis.host=127.0.0.1 # Redis 服务器端口 spring.redis.port=6379 # 如果有密码 # spring.redis.password=yourpassword application.yml 示例:\nYAML\n1 2 3 4 5 spring: redis: host: 127.0.0.1 port: 6379 # password: yourpassword 完成了！\n是的，就这么简单。Spring Boot 的自动配置机制非常强大。当它检测到 Redis 的依赖和配置后，会自动创建并配置一个 RedisCacheManager 来替代默认的 ConcurrentHashMap 缓存。\n你的 Java 代码（@Cacheable 等注解）完全不需要做任何改动。这就是 Spring Cache 设计的优雅之处：业务代码与具体的缓存实现是解耦的。\n6. 高级主题和常用配置 6.1 自定义 Key 生成策略 默认情况下，Key 的生成规则是：\n如果没有参数，Key 是一个 SimpleKey.EMPTY 常量。\n如果只有一个参数，Key 就是这个参数的实例。\n如果有多个参数，Key 是一个包含了所有参数的 SimpleKey。\n大多数情况下，使用 SpEL key=\u0026quot;...\u0026quot; 属性就足够了。但你也可以创建全局的 Key 生成器。\n6.2 条件缓存 condition 和 unless condition: 在方法执行前判断，只有条件为 true，才会走缓存逻辑（查询或存入）。\nunless: 在方法执行后判断，只有条件为 false，才会将方法的返回值放入缓存。通常用来过滤掉不希望缓存的结果（比如，返回值为 null）。\n示例：\nJava\n1 2 3 4 5 6 7 // 只有当参数 id 大于 1 时，才使用缓存 @Cacheable(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;, condition = \u0026#34;#id \u0026gt; 1\u0026#34;) public User findUserById(Long id) { ... } // 如果查询结果的用户名为 \u0026#34;guest\u0026#34;，则不缓存这个结果 @Cacheable(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#id\u0026#34;, unless = \u0026#34;#result.username == \u0026#39;guest\u0026#39;\u0026#34;) public User findUserById(Long id) { ... } #result 是 SpEL 中一个特殊的变量，代表方法的返回值。\n6.3 统一配置缓存过期时间 (TTL) 在 application.properties 或 application.yml 中可以统一配置缓存的过期时间。\napplication.properties 示例:\nProperties\n1 2 3 4 5 6 7 # 全局设置所有缓存的默认过期时间为 10 分钟 spring.cache.redis.time-to-live=10m # 针对名为 \u0026#34;users\u0026#34; 的缓存，设置其过期时间为 30 分钟 spring.cache.redis.cache-names=users,products spring.cache.redis.initial-cache-configuration.users.time-to-live=30m spring.cache.redis.initial-cache-configuration.products.time-to-live=1h application.yml 示例:\nYAML\n1 2 3 4 5 6 7 8 9 10 spring: cache: redis: time-to-live: 10m # 全局默认10分钟 cache-names: users,products initial-cache-configuration: users: time-to-live: 30m # users缓存30分钟 products: time-to-live: 1h # products缓存1小时 6.4 @Caching 组合注解 如果你想对一个方法应用多个缓存操作，比如同时清除多个缓存，可以使用 @Caching。\nJava\n1 2 3 4 5 6 7 8 @Caching(evict = { @CacheEvict(cacheNames = \u0026#34;users\u0026#34;, key = \u0026#34;#user.id\u0026#34;), @CacheEvict(cacheNames = \u0026#34;user-list\u0026#34;, allEntries = true) }) public User updateUser(User user) { // ... 更新逻辑 return user; } 这个例子在更新用户后，既清除了该用户的单条缓存，也清除了一个可能存在的用户列表缓存。\n7. 总结 Spring Cache 是一个非常实用且强大的工具，它通过声明式的方式（注解）将缓存逻辑与业务逻辑解耦，让开发者能更专注于业务本身。\n入门学习路径建议：\n理解核心思想：通过缓存减少对慢速资源的访问。\n掌握三大注解：@Cacheable (查询), @CachePut (更新), @CacheEvict (删除)。\n实践操作：在 Spring Boot项目中，通过引入依赖、开启注解、配置 application.yml 来集成 Redis。\n深入学习：探索 key 的 SpEL 写法、condition/unless 条件缓存以及统一的过期时间配置。\n","date":"2025-07-03T15:05:20+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spring-cache-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","title":"Spring Cache 入门笔记"},{"content":"Redis 是一个开源的内存数据结构存储，可以用作数据库、缓存和消息中间件。与传统的关系型数据库不同，Redis 将数据存储在内存中，这使得它的读写速度非常快。它支持多种数据结构，这让它在处理各种场景时都非常灵活。\n下面我们来深入了解 Redis 最常用的五种数据类型：\n1. 字符串 (String) Redis 中最基本的数据类型就是 字符串 (String)。它不仅仅能存储普通的文本字符串，还能存储二进制数据（比如图片、视频、序列化的 Java 对象），最大可以达到 512MB。\n理解： 你可以把 Redis 的 String 类型想象成 Java 中的 String 类型，但它还能存储更广泛的数据。\n常用场景：\n缓存： 存储用户的 Session 信息、热门文章的标题等。 计数器： 记录网站的访问量、商品的点赞数等。 简单键值对： 存储配置信息、用户信息等。 常用命令：\nSET key value：设置键值对。 GET key：获取键的值。 INCR key：将键的值加 1（如果值为数字）。 DECR key：将键的值减 1。 EXPIRE key seconds：设置键的过期时间。 示例：\n1 2 3 4 5 6 7 8 SET username \u0026#34;zhangsan\u0026#34; GET username // 返回 \u0026#34;zhangsan\u0026#34; SET page_views 0 INCR page_views // 返回 1 INCR page_views // 返回 2 SET product:1001:name \u0026#34;MacBook Pro\u0026#34; EXPIRE 60 // 设置键值并使其在60秒后过期 2. 哈希 (Hash) 哈希 (Hash) 类型用于存储对象。它是一个键值对的集合，其中每个键都关联一个值。你可以把它理解为 Java 中的 HashMap\u0026lt;String, String\u0026gt;，在一个 Redis 的 key 下，又可以存储多个字段和值。\n理解： 如果你需要在 Redis 中存储一个 Java 对象（比如用户信息），那么 Hash 类型是最好的选择。\n常用场景：\n存储对象： 存储用户信息（姓名、年龄、邮箱等）、商品信息等。 购物车： 存储用户购物车中的商品及其数量。 常用命令：\nHSET key field value：设置哈希表中指定字段的值。 HGET key field：获取哈希表中指定字段的值。 HGETALL key：获取哈希表中所有字段和值。 HDEL key field1 [field2...]：删除哈希表中的一个或多个字段。 示例：\n1 2 3 4 5 6 HSET user:1001 name \u0026#34;lisi\u0026#34; age 30 email \u0026#34;lisi@example.com\u0026#34; HGET user:1001 name // 返回 \u0026#34;lisi\u0026#34; HGETALL user:1001 // 返回 name \u0026#34;lisi\u0026#34; age \u0026#34;30\u0026#34; email \u0026#34;lisi@example.com\u0026#34; HSET product:laptop brand \u0026#34;Dell\u0026#34; model \u0026#34;XPS 15\u0026#34; price 12000 HGET product:laptop price // 返回 \u0026#34;12000\u0026#34; 3. 列表 (List) 列表 (List) 类型是一个有序的字符串集合，可以从列表的两端添加或删除元素。你可以把它想象成一个双向链表，或者 Java 中的 LinkedList。\n理解： List 非常适合用来实现队列、栈这样的数据结构。\n常用场景：\n消息队列： 实现生产者-消费者模式。 最新文章列表： 存储网站的最新发布的文章 ID。 朋友圈时间线： 存储用户发布的朋友圈内容。 常用命令：\nLPUSH key value1 [value2...]：将一个或多个值插入到列表的头部。\nRPUSH key value1 [value2...]：将一个或多个值插入到列表的尾部。\nLPOP key：移除并返回列表的第一个元素。\nRPOP key：移除并返回列表的最后一个元素。\nLRANGE key start stop：获取列表中指定范围内的元素。\nLLEN key：获取列表的长度。\n示例：\n1 2 3 4 5 LPUSH mylist \u0026#34;apple\u0026#34; \u0026#34;banana\u0026#34; \u0026#34;orange\u0026#34; LRANGE mylist 0 -1 // 返回 \u0026#34;orange\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34; (从左到右) RPUSH tasks \u0026#34;task1\u0026#34; \u0026#34;task2\u0026#34; LPOP tasks // 返回 \u0026#34;task1\u0026#34; (模拟队列消费) 4. 集合 (Set) 集合 (Set) 类型是一个无序的字符串集合，每个元素都是唯一的，不允许重复。它类似于 Java 中的 HashSet。\n理解： Set 主要用于存储不重复的数据，并能进行集合间的运算（交集、并集、差集）。\n常用场景：\n标签系统： 存储文章的标签。 共同关注/共同好友： 计算两个用户之间的共同关注。 抽奖活动： 存储参与抽奖的用户 ID，确保不重复。 常用命令：\nSADD key member1 [member2...]：向集合中添加一个或多个成员。 SMEMBERS key：获取集合中的所有成员。 SISMEMBER key member：判断成员是否是集合的成员。 SREM key member1 [member2...]：移除集合中的一个或多个成员。 SINTER key1 [key2...]：返回给定所有集合的交集。 SUNION key1 [key2...]：返回给定所有集合的并集。 SDIFF key1 [key2...]：返回给定所有集合的差集。 示例：\n1 2 3 4 5 6 SADD tags \u0026#34;Java\u0026#34; \u0026#34;Spring\u0026#34; \u0026#34;Redis\u0026#34; SMEMBERS tags // 返回 \u0026#34;Java\u0026#34;, \u0026#34;Spring\u0026#34;, \u0026#34;Redis\u0026#34; (无序) SADD user:1:friends \u0026#34;user2\u0026#34; \u0026#34;user3\u0026#34; \u0026#34;user4\u0026#34; SADD user:2:friends \u0026#34;user3\u0026#34; \u0026#34;user4\u0026#34; \u0026#34;user5\u0026#34; SINTER user:1:friends user:2:friends // 返回 \u0026#34;user3\u0026#34;, \u0026#34;user4\u0026#34; (共同好友) 5. 有序集合 (Sorted Set / ZSet) 有序集合 (Sorted Set / ZSet) 类型和 Set 类似，也是字符串的集合，且每个元素都是唯一的。不同之处在于，有序集合的每个成员都会关联一个 分数 (score)，Redis 会根据分数对集合中的成员进行排序。分数可以是小数。\n理解： ZSet 可以看作是 Set 和 Hash 的结合，既保证元素的唯一性，又能根据分数进行排序。\n常用场景：\n排行榜： 游戏积分排行榜、销售排行榜等。 最新热点： 根据时间戳或热度分数排序。 带有权重的任务队列： 根据任务的优先级进行处理。 常用命令：\nZADD key score member1 [score member2...]：向有序集合中添加一个或多个成员，或者更新已存在成员的分数。 ZRANGE key start stop [WITHSCORES]：通过索引区间返回有序集合指定区间内的成员。 ZREVRANGE key start stop [WITHSCORES]：通过索引区间返回有序集合中指定区间内的成员，分数从大到小。 ZSCORE key member：获取有序集合中指定成员的分数。 ZREM key member1 [member2...]：移除有序集合中的一个或多个成员。 示例：\n1 2 3 4 5 6 ZADD leaderboard 95 \u0026#34;Alice\u0026#34; 88 \u0026#34;Bob\u0026#34; 92 \u0026#34;Charlie\u0026#34; ZRANGE leaderboard 0 -1 WITHSCORES // 返回 \u0026#34;Bob\u0026#34; 88, \u0026#34;Charlie\u0026#34; 92, \u0026#34;Alice\u0026#34; 95 (分数从小到大) ZREVRANGE leaderboard 0 1 WITHSCORES // 返回 \u0026#34;Alice\u0026#34; 95, \u0026#34;Charlie\u0026#34; 92 (分数从大到小，取前两名) ZADD product:sales 1000 \u0026#34;iPhone\u0026#34; 800 \u0026#34;iPad\u0026#34; 1200 \u0026#34;MacBook\u0026#34; ZREVRANGE product:sales 0 0 WITHSCORES // 返回 \u0026#34;MacBook\u0026#34; 1200 (销量最高的产品) 如何在 Spring Boot 中使用 Redis？ 在 Spring Boot 中集成 Redis 非常方便，通常会使用 spring-boot-starter-data-redis 依赖。它提供了对 Jedis 或 Lettuce 客户端的自动配置。\n1. 添加依赖：\n在 pom.xml 中添加如下依赖：\nXML\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 2. 配置 Redis 连接：\n在 application.properties 或 application.yml 中配置 Redis 连接信息：\nProperties\n1 2 3 4 # application.properties spring.data.redis.host=localhost spring.data.redis.port=6379 # spring.data.redis.password=your_password (如果有密码的话) 3. 使用 RedisTemplate 或 StringRedisTemplate：\nSpring Boot 会自动配置 RedisTemplate 和 StringRedisTemplate。你可以直接在你的服务类中注入它们来操作 Redis。\nRedisTemplate\u0026lt;K, V\u0026gt;： 默认使用 JDK 序列化，可以操作各种 Java 对象。 StringRedisTemplate： RedisTemplate 的子类，专门用于操作字符串类型，键和值都使用 StringRedisSerializer 进行序列化。 示例：\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Service; @Service public class UserService { @Autowired private StringRedisTemplate stringRedisTemplate; // 用于操作字符串 @Autowired private RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate; // 用于操作Java对象 public void saveUser(String userId, String username) { stringRedisTemplate.opsForValue().set(\u0026#34;user:\u0026#34; + userId + \u0026#34;:name\u0026#34;, username); } public String getUserName(String userId) { return stringRedisTemplate.opsForValue().get(\u0026#34;user:\u0026#34; + userId + \u0026#34;:name\u0026#34;); } public void incrementPageViews(String articleId) { stringRedisTemplate.opsForValue().increment(\u0026#34;article:\u0026#34; + articleId + \u0026#34;:views\u0026#34;); } public void addUserToRanking(String username, double score) { redisTemplate.opsForZSet().add(\u0026#34;game:ranking\u0026#34;, username, score); } } ","date":"2025-06-19T22:26:09+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/redis%E4%BA%94%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Redis五种常用数据类型"},{"content":"六级翻译高频词汇分类表 一、中国传统文化类 中文词汇 英文表达 备注说明 四书五经 The Four Books and Five Classics 儒家经典著作统称 四大名著 Four Great Classical Novels 包括《红楼梦》《西游记》等 唐诗宋词 Tang Poetry and Song Ci-poetry 中国古典文学巅峰代表 书法 Calligraphy 中国传统艺术形式 京剧 Beijing Opera 国粹，被称为 \u0026ldquo;东方歌剧\u0026rdquo; 春节 Spring Festival 中国最重要传统节日 端午节 Dragon Boat Festival 纪念屈原，有吃粽子划龙舟习俗 故宫 Forbidden City 明清皇家宫殿，世界文化遗产 长城 The Great Wall 世界七大奇迹之一 园林 Classical Garden 以苏州园林为代表 二、经济社会发展类 中文词汇 英文表达 备注说明 改革开放 Reform and Opening-up 中国重要发展战略 市场经济 Market Economy 现代经济体系核心 可持续发展 Sustainable Development 全球发展共识 GDP Gross Domestic Product 国内生产总值简称 人均收入 Per Capita Income 衡量生活水平重要指标 城市化 Urbanization 社会发展重要进程 老龄化社会 Aging Society 面临养老医疗等挑战 教育公平 Education Equality 社会公平重要组成部分 脱贫攻坚 Poverty Alleviation 中国重要民生工程 乡村振兴 Rural Revitalization 新时代农村发展战略 三、科技环保类 中文词汇 英文表达 备注说明 人工智能 Artificial Intelligence (AI) 前沿科技领域 大数据 Big Data 现代信息技术核心 云计算 Cloud Computing 互联网服务新模式 5G 技术 5G Technology 第五代移动通信技术 电子商务 E-commerce 网络经济重要形式 高铁 High-speed Railway 中国新四大发明之一 共享单车 Shared Bicycles 绿色出行代表 环境污染 Environmental Pollution 全球关注问题 低碳经济 Low-carbon Economy 应对气候变化重要路径 垃圾分类 Garbage Classification 环保新时尚 四、文化教育类 中文词汇 英文表达 备注说明 文化交流 Cultural Exchange 文明互鉴重要方式 文化遗产 Cultural Heritage 包括物质与非物质遗产 孔子学院 Confucius Institute 汉语国际推广平台 丝绸之路 Silk Road 古代东西方交流通道 义务教育 Compulsory Education 国家教育基本制度 高等教育 Higher Education 培养专业人才关键 素质教育 Quality-oriented Education 教育改革方向 留学 Study Abroad 国际教育交流重要形式 学术交流 Academic Exchange 科研合作重要途径 文凭 Diploma 学历证明文件 五、高频动词短语类 中文表达 英文短语 典型例句 促进 Promote / Facilitate Promote economic development 推动 Drive / Propel Drive social progress 实现 Achieve / Realize Achieve the goal 影响 Influence / Affect Affect people\u0026rsquo;s lifestyle 保护 Protect / Preserve Protect cultural heritage 弘扬 Carry forward Carry forward traditional values 重视 Attach importance to Attach importance to education 致力于 Be committed to Be committed to environmental protection 以\u0026hellip; 为基础 Be based on The theory is based on practice 被认为是 Be regarded as It is regarded as a symbol of China 六、中国特色事物类 中文词汇 英文表达 文化说明 中医 Traditional Chinese Medicine (TCM) 中国传统医学体系 太极拳 Tai Chi 传统武术与养生结合 功夫 Kung Fu 中国武术统称 豆腐 Tofu 传统豆制品，素食代表 饺子 Dumpling 传统面食，春节必备 筷子 Chopsticks 独特用餐工具 火锅 Hot Pot 特色饮食文化 旗袍 Cheongsam 传统女性服饰 麻将 Mahjong 传统棋牌游戏 针灸 Acupuncture 中医特色疗法 七、逻辑连接词类 逻辑关系 中文表达 英文词汇 因果关系 因为 Because / Since / As 因果关系 由于 Due to / Because of 因果关系 因此 Thus / Therefore / Consequently 转折关系 但是 But / However / Yet 转折关系 尽管 Although / Though / Despite 并列关系 和 And / With 并列关系 不仅\u0026hellip; 而且\u0026hellip; Not only\u0026hellip;but also\u0026hellip; 条件关系 如果 If / Provided that 时间关系 随着 With / As 时间关系 自从 Since 八、形容词副词类 词性 中文表达 英文词汇 形容词 重要的 Important / Significant / Crucial 形容词 快速的 Rapid / Swift / Fast 形容词 巨大的 Huge / Enormous / Gigantic 形容词 独特的 Unique / Distinctive 形容词 传统的 Traditional / Classical 副词 越来越\u0026hellip; Increasingly / More and more 副词 广泛地 Widely / Extensively 副词 迅速地 Rapidly / Swiftly 副词 尤其 Especially / Particularly 副词 逐渐地 Gradually / Step by step ","date":"2025-06-07T16:18:10+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%85%AD%E7%BA%A7%E7%BF%BB%E8%AF%91%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87/","title":"六级翻译高频词汇"},{"content":"一、无主句的处理方式 （一）被动语态 结构：主语（动作承受者）+ be 动词 + 过去分词 + 其他 示例：千百年来，创作了许多诗歌和绘画赞美牡丹。 英文：Over thousands of years，a lot of poetry and drawings have been created to praise/honor peony. （二）添加主语（人们，我们，他们等） 示例：普通大众也喜爱梅花，春节期间常用于家庭装饰。 英文：Ordinary people also like plum blossom. It is often used for family decoration during Spring Festival. （三）there be 句型 结构：There be + 主语 + 其他 示例：近年来，也出现了许多数字图书馆，从而节省了存放图书所需的空间。 英文：In recent years，many digital libraries have emerged. As a consequence，space for storing books is saved. 二、原因表达 （一）原因从句引导词 since，for，because，as 示例：但由于汉字有统一的书写形式，他们交流起来几乎没有任何困难。 英文：Since Chinese characters have a uniform written way，they can communicate without any difficulty. （二）介词短语 because of + 名词 due to + （多为负面）原因 thanks to + （多为正面）原因 示例：由于空气污染日益严重，现在越来越多的人选择购买新能源汽车。 英文：Due to the increasingly serious air pollution，nowadays，a growing number of people choose to purchase new energy cars. 三、“因\u0026hellip; 而出名” 的表达 be known for /be famous for /be renowned for：后接出名的原因 be known as：后接名声、称号 示例 1：太湖以其独特的 “太湖石” 而闻名。 英文：Taihu Lake is renowned for its unique “Taihu stones/rock”. 示例 2：潍坊以 “风筝之都” 而闻名，已有将近 2400 年放飞风筝的历史。 英文：Weifang is known as the “Kite Capital”，and has a history of flying kites for nearly 2400 years. 四、时间相关的时态 （一）现在完成进行时（have/has been doing） 表示动作从过去开始，持续到现在，可能还会继续下去 示例：几千年来，长江一直被用于供水、运输和工业生产。 英文：For thousands of years，the Yangtze River has been being used for water supply，transportation and industrial production. （二）现在完成时（have/has done） 表示动作在过去发生，对现在有影响或结果 示例 1：数百年来，当地人沿着河边建起了住宅和集市。 英文：For /over hundreds of years，locals have built houses and markets along the river. 示例 2：在过去的几十年里，政府采取了各种措施防止灾害发生。 英文：Over the past decades，the government has taken various measures to prevent disasters. 示例 3：自上世纪 90 年代安装缆车以来，参观人数大大增加。 英文：Since the installation of cable car in the 1990s，the number of visitors has increased considerably. 五、其他实用句型 （一）with 引导的伴随状语 结构：With + 名词 + 介词短语 / 分词等 示例 1：随着中国经济的快速增长和全球影响力的增强，越来越多其他国家的人也开始学习汉语。 英文：With the rapid growth of Chinese economy and the enhancement of global influence，an increasing number of people from other countries begin to learn Chinese. 示例 2：可以预见，随着运动设施的不断改善，愈来愈多的人将会去体育馆健身。 英文：It can be predicted that with the continuous improvement of sport facilities， an increasing number of people will go to the stadium to work out. （二）被动语态的灵活使用 示例：方言被认为是当地文化的一个组成部分。 英文：Dialects are considered as an integral part of local cultures. 示例：成语在日常生活中和文学创作中广泛使用。 英文：Idioms are widely used in daily conversation and literature creation. / People frequently use idioms in daily conversation and literature creation. （三）省略主语的情况（通过上下文或语境暗示主语） 示例：修建之初是为了运输粮食，后来也被用于运输其他商品。 英文：It was first built for transporting crops/food/grain/wheat and later for transporting other goods/commodities. （四）含时间状语从句的句型 示例：自 1986 年《义务教育法》生效以来，经过不懈努力，实现了在全国推行义务教育的目标。 英文：Since the Compulsory Education Law came into effect in 1986，after tireless efforts，the goal to implement compulsory education throughout the country has been realized. ","date":"2025-06-07T16:15:38+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%85%AD%E7%BA%A7%E7%BF%BB%E8%AF%91%E4%BA%8C/","title":"六级翻译（二）"},{"content":"一、翻译基本步骤 找主干\n确定句子核心结构：谁是什么（主系表）、谁做什么（主谓宾）、什么被做（被动语态）。\n例：《水浒传》是中国文学四大经典之一。\n主干：Water Margin is one of the four classical novels. 添枝加叶（修饰成分）\n补充定语、状语等修饰内容，通过从句、介词短语、分词结构等实现。\n例：明朝统治中国 276 年，被人们描绘成人类历史上治理有序、社会稳定的最伟大的时代之一。\n修饰成分：which has ruled China for 276 years（定语从句），in human history（介词短语作定语）。 检查回读\n重点核对：主谓一致、时态正确、单复数一致、无漏译错译。\n二、核心句型与表达 （一）one of + 名词复数结构 用法：表示 “…… 之一”，名词需用复数形式，谓语动词用单数。\n例 1：珠江三角洲已成为中国和世界主要经济区域和制造中心之一。\nThe Pearl River Delta has become one of the major economic regions and manufacturing centers in China and the world. 例 2：黄山是中国主要旅游目的地之一。\nHuangshan is one of the major tourist destinations in China.\n补充：“名胜古迹” 可译为 tourist attraction。 例 3：大运河是中国历史上最宏伟的工程之一。\nThe Grand Canal is one of the grandest projects in Chinese history. （二）“越来越……” 的表达 越来越多 more and more / a growing number of / an increasing number of 例：越来越多的外国读者感到这部小说故事生动感人。\nA growing number of foreign readers find the story in this novel vivid and touching. 程度递进（副词 + 形容词） increasingly + adj. /better and better（多用于口语） 例：如今，在中国乘地铁正变得越来越方便。\nTaking subway in China is becoming increasingly convenient. （三）经典句式积累 A 使 B 成为…… 结构：A has made B + n. /adj. 例：都江堰使成都平原成为旱涝保收的沃土。\nDujiangyan has made the Chengdu Plain a fertile land whether in drought or flood. 随着……，越来越多…… 结构：With + n. + 发展，a growing number of\u0026hellip; + 谓语 例：随着中国经济增长，越来越多人开始学汉语。\nWith the rapid growth of Chinese economy, a growing number of people from other countries start to learn Chinese. 被动语态表达 结构：主语 + be + 过去分词 + 修饰语 例：明朝被描绘成最伟大的时代之一。\nThe Ming Dynasty is described as one of the greatest eras in human history. （四）高频词汇与搭配 中文表达 英文对应词汇 / 短语 例句示例 经济区域 economic region The Pearl River Delta is a major economic region. 制造中心 manufacturing center It has become a global manufacturing center. 产茶地 tea-producing place Huangshan is one of China’s major tea-producing places. 高铁 high-speed train More people travel by high-speed train during holidays. 拓展视野 broaden one’s horizons Studying abroad helps broaden students’ horizons. 改革开放 reform and opening up Thanks to reform and opening up, China has developed rapidly. 人工河 artificial / man-made river The Grand Canal is the longest man-made river in the world. （五）易错点提醒 单复数一致 one of 后必须接名词复数，如 “one of the four classical novels”（而非 novel）。 时态选择 表达历史事实用一般过去时，如 “The Ming Dynasty ruled China for 276 years.”； 强调持续影响用现在完成时，如 “Dujiangyan has made the Chengdu Plain a fertile land.”。 介词搭配 “从…… 到……” 用 start from\u0026hellip;to\u0026hellip;，如 “The canal starts from Beijing to Hangzhou.”； “有利于……” 用 be beneficial to，如 “Humid climate is beneficial to tea trees.”。 三、翻译实战练习（附参考译文） （一）句子翻译 原文：苏州是中国最著名的园林城市之一，以古典园林闻名于世。\n参考译文：Suzhou is one of the most famous garden cities in China, renowned for its classical gardens. 原文：随着科技发展，越来越多的人选择在线学习。\n参考译文：With the development of technology, an increasing number of people choose to study online. （二）段落翻译（节选） 原文：\n近年来，中国越来越多的博物馆免费向公众开放。如今，展览形式越来越多样，越来越多的人在假日参观博物馆，拓展文化视野。\n参考译文：\nIn recent years, an increasing number of museums in China have been open to the public for free. Nowadays, there are more and more forms of exhibitions, and a growing number of people visit museums during holidays to broaden their cultural horizons.\n","date":"2025-06-07T16:14:03+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%85%AD%E7%BA%A7%E7%BF%BB%E8%AF%91%E4%B8%80/","title":"六级翻译（一）"},{"content":"英语六级作文 三个类型-三种写法 现象解释-是什么，为什么\n问题选择-解决方式\n观点选择- 某个观点为什么正确\n三个段落 现象解释型​\n第一段（引出背景与过渡）​\nIn the contemporary world, (主题词) have/has become increasingly important. It’s of great necessity for (students/xxx) to 做某件事. 当今世界，____________已经变得越来越重要。对于 xxx 来说，做某件事非常的有必要。​\nReasons and concrete evidence to support my view point are as follows. 以下原因和具体证据可以支撑我的观点。​\n第二段（论点与论据）​\n论点 1：In the first place, there is no doubt that （写简单句，保证正确）. 首先毫无疑问的是_______。​\n论据 1：Based on big data, most of _______ admitted that (they’ve spent 2/3 of their time in doing sth.). 基于大数据，大多数_______承认(他们花了 2/3 的时间做某事)。​\n论点 2：Moreover，no one can deny that .(观点 2) 此外，没有人可以否认。( 观点 2)​(xxx can enhances resilience,xxx增加你的韧性。)\n论据 2：万能谚语 ——where there is/are ________________, there is/are .（有, 就有.） 例句：where there is a will, there is a way 有志者事竟成；where there is Internet, there are accesses to online courses. 哪里有互联网，哪里就可以访问在线课程。​\n论点 3 ：Last but not least, I firmly believe that ____________.(观点 3) 最后我坚定地认为 xxx。​\n论据 3：​\n加分版：The + 比较级 + 动词，the + 比较级 + 动词。 越……， 越…….. 例如：the more fans you have, the happier you are​\n简单版：Although ….,…..​\n第三段（总结）​\nIn conclusion, (xxx 是非常重要的)__________. If we spare no efforts to ______, the future of ____________ will be both hopeful and rosy. 总之，xxx 是非常重要的，如果我们不遗余力的做某件事，我们的未来就会变得既有前途又有希望。\n","date":"2025-06-05T14:25:37+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%85%AD%E7%BA%A7%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/","title":"六级作文模板"},{"content":"Vuex 四大核心辅助函数详解 Vuex 是 Vue.js 应用程序的状态管理模式和库。当我们的应用逐渐复杂，组件之间共享和传递状态变得困难时，Vuex 提供了一个集中的存储来管理所有组件的状态。为了更方便地在组件中使用 Vuex store 中的状态 (state)、取值器 (getters)、变更 (mutations) 和动作 (actions)，Vuex 提供了这些辅助函数。它们的主要目的是简化模板代码，减少冗余。\n🗺️ mapState mapState 辅助函数用于帮助我们方便地在组件的计算属性 (computed) 中映射 store 中的 state。\n🧩 不用 mapState 当不使用 mapState 时，我们需要为每一个需要从 store 中读取的状态手动创建一个计算属性。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: {{ message }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;User: {{ user.firstName }} {{ user.lastName }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { // 手动定义计算属性来获取 store 中的 state count() { return this.$store.state.count; // 直接访问 $store.state }, message() { return this.$store.state.message; // 直接访问 $store.state }, user() { return this.$store.state.user; // 直接访问 $store.state } } }; \u0026lt;/script\u0026gt; 注释说明:\n在 computed 对象中，我们为 count、message 和 user 分别定义了计算属性。 每个计算属性都返回 this.$store.state 中对应的状态值。 ✅ 用了 mapState 使用 mapState 后，代码会变得更加简洁。它可以接收一个数组或一个对象作为参数。\n1. 传递字符串数组：\n当映射的计算属性的名称与 state 子树的名称相同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: {{ message }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Local Computed: {{ localComputed }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapState } from \u0026#39;vuex\u0026#39;; export default { data() { return { localData: \u0026#39;这是局部数据\u0026#39; }; }, computed: { // 局部计算属性 localComputed() { return this.localData.toUpperCase(); }, // 使用 mapState 辅助函数将 store 中的 state 映射到局部计算属性 ...mapState([ \u0026#39;count\u0026#39;, // 映射 this.count 为 store.state.count \u0026#39;message\u0026#39; // 映射 this.message 为 store.state.message ]) } }; \u0026lt;/script\u0026gt; 注释说明:\n我们从 vuex 导入 mapState 函数。 使用对象展开运算符 (...) 将 mapState 返回的对象混入到 computed 对象中。 mapState(['count', 'message']) 会生成 { count() { return this.$store.state.count }, message() { return this.$store.state.message } }。 2. 传递对象：\n当映射的计算属性的名称与 state 子树的名称不同，或者需要更复杂的取值时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Current Count: {{ currentCount }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;App Message: {{ appMessage }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Full Name: {{ fullName }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapState } from \u0026#39;vuex\u0026#39;; export default { computed: { ...mapState({ currentCount: \u0026#39;count\u0026#39;, // 将 this.currentCount 映射为 store.state.count appMessage: state =\u0026gt; state.message, // 可以使用函数进行更灵活的映射 fullName: state =\u0026gt; `${state.user.firstName} ${state.user.lastName}` // 访问深层嵌套的状态 }) } }; \u0026lt;/script\u0026gt; 注释说明:\ncurrentCount: 'count' 表示将组件内的计算属性 currentCount 映射到 Vuex store 中的 state.count。 appMessage: state =\u0026gt; state.message 和 fullName: state =\u0026gt; ... 展示了如何使用函数来获取 state，这提供了更大的灵活性，例如当 state 的值需要计算或来自嵌套对象时。 📊 mapGetters mapGetters 辅助函数用于将 store 中的 getters 映射到组件的计算属性 (computed) 中。Getters 可以看作是 store 的计算属性。\n🧩 不用 mapGetters 不使用 mapGetters 时，你需要为每个 getter 手动创建计算属性。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Doubled Count: {{ doubledCountValue }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Welcome: {{ welcomeText }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { computed: { // 手动定义计算属性来获取 store 中的 getter doubledCountValue() { return this.$store.getters.doubledCount; // 通过 $store.getters 访问 }, welcomeText() { return this.$store.getters.welcomeMessage; // 通过 $store.getters 访问 } } }; \u0026lt;/script\u0026gt; 注释说明:\ndoubledCountValue 和 welcomeText 计算属性分别从 this.$store.getters 获取对应的 getter 值。 ✅ 用了 mapGetters 使用 mapGetters 可以简化这个过程。它也支持数组和对象两种形式。\n1. 传递字符串数组：\n当映射的计算属性的名称与 getter 的名称相同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Doubled Count: {{ doubledCount }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Welcome: {{ welcomeMessage }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapGetters } from \u0026#39;vuex\u0026#39;; export default { computed: { // 使用 mapGetters 辅助函数将 store 中的 getters 映射到局部计算属性 ...mapGetters([ \u0026#39;doubledCount\u0026#39;, // 映射 this.doubledCount 为 store.getters.doubledCount \u0026#39;welcomeMessage\u0026#39; // 映射 this.welcomeMessage 为 store.getters.welcomeMessage ]) } }; \u0026lt;/script\u0026gt; 注释说明:\nmapGetters(['doubledCount', 'welcomeMessage']) 会生成相应的计算属性，它们的值来源于 Vuex store 中的同名 getters。 2. 传递对象：\n当映射的计算属性的名称与 getter 的名称不同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Calculated Double: {{ calcDouble }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Greeting: {{ greeting }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapGetters } from \u0026#39;vuex\u0026#39;; export default { computed: { ...mapGetters({ calcDouble: \u0026#39;doubledCount\u0026#39;, // 将 this.calcDouble 映射为 store.getters.doubledCount greeting: \u0026#39;welcomeMessage\u0026#39; // 将 this.greeting 映射为 store.getters.welcomeMessage }) } }; \u0026lt;/script\u0026gt; 注释说明:\ncalcDouble: 'doubledCount' 将组件的 calcDouble 计算属性映射到 store 的 doubledCount getter。 🧬 mapMutations mapMutations 辅助函数用于将 store 中的 mutations 映射到组件的 methods 中。这样你就可以在组件方法中直接调用 this.mutationName(payload) 来提交 mutation，而不是使用 this.$store.commit('mutationName', payload)。\n🧩 不用 mapMutations 不使用 mapMutations 时，你需要为每个 mutation 手动创建方法来调用 this.$store.commit。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;incrementCountManually\u0026#34;\u0026gt;Increment Count Manually\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;setMessageManually(\u0026#39;New Manual Message\u0026#39;)\u0026#34;\u0026gt;Set Message Manually\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { // 手动定义方法来提交 mutation incrementCountManually() { this.$store.commit(\u0026#39;INCREMENT_COUNT\u0026#39;, 5); // 手动调用 $store.commit }, setMessageManually(newMessage) { this.$store.commit(\u0026#39;SET_MESSAGE\u0026#39;, newMessage); // 手动调用 $store.commit } } }; \u0026lt;/script\u0026gt; 注释说明:\nincrementCountManually 方法通过 this.$store.commit('INCREMENT_COUNT', 5) 来提交 INCREMENT_COUNT mutation，并传递 payload 5。 setMessageManually 方法提交 SET_MESSAGE mutation，并传递新的消息字符串。 ✅ 用了 mapMutations 使用 mapMutations 可以将 mutations 映射为组件的 methods。\n1. 传递字符串数组：\n当映射的方法名与 mutation 名相同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: {{ $store.state.message }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;INCREMENT_COUNT(2)\u0026#34;\u0026gt;Increment Count\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;SET_MESSAGE(\u0026#39;Hello from mapMutations!\u0026#39;)\u0026#34;\u0026gt;Set Message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapMutations } from \u0026#39;vuex\u0026#39;; export default { methods: { // 使用 mapMutations 辅助函数将 store 中的 mutations 映射到局部方法 ...mapMutations([ \u0026#39;INCREMENT_COUNT\u0026#39;, // 映射 this.INCREMENT_COUNT() 为 this.$store.commit(\u0026#39;INCREMENT_COUNT\u0026#39;) \u0026#39;SET_MESSAGE\u0026#39; // 映射 this.SET_MESSAGE() 为 this.$store.commit(\u0026#39;SET_MESSAGE\u0026#39;) ]) // 调用 this.INCREMENT_COUNT(payload) 等同于 this.$store.commit(\u0026#39;INCREMENT_COUNT\u0026#39;, payload) } }; \u0026lt;/script\u0026gt; 注释说明:\nmapMutations(['INCREMENT_COUNT', 'SET_MESSAGE']) 会将 INCREMENT_COUNT 和 SET_MESSAGE mutations 映射为组件的同名方法。 调用 this.INCREMENT_COUNT(2) 时，2 会作为 payload 传递给 INCREMENT_COUNT mutation。 2. 传递对象：\n当映射的方法名与 mutation 名不同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;addCount(3)\u0026#34;\u0026gt;Add to Count\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeMessage(\u0026#39;Message updated via alias!\u0026#39;)\u0026#34;\u0026gt;Change App Message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapMutations } from \u0026#39;vuex\u0026#39;; export default { methods: { ...mapMutations({ addCount: \u0026#39;INCREMENT_COUNT\u0026#39;, // 将 this.addCount() 映射为 this.$store.commit(\u0026#39;INCREMENT_COUNT\u0026#39;) changeMessage: \u0026#39;SET_MESSAGE\u0026#39; // 将 this.changeMessage() 映射为 this.$store.commit(\u0026#39;SET_MESSAGE\u0026#39;) }) // 调用 this.addCount(payload) 等同于 this.$store.commit(\u0026#39;INCREMENT_COUNT\u0026#39;, payload) } }; \u0026lt;/script\u0026gt; 注释说明:\naddCount: 'INCREMENT_COUNT' 将组件的 addCount 方法映射到名为 INCREMENT_COUNT 的 mutation。调用 this.addCount(3) 实际上是执行 this.$store.commit('INCREMENT_COUNT', 3)。 🚀 mapActions mapActions 辅助函数用于将 store 中的 actions 映射到组件的 methods 中。这样你就可以在组件方法中直接调用 this.actionName(payload) 来分发 action，而不是使用 this.$store.dispatch('actionName', payload)。\n🧩 不用 mapActions 不使用 mapActions 时，你需要为每个 action 手动创建方法来调用 this.$store.dispatch。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: {{ $store.state.message }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;incrementAsyncManually\u0026#34;\u0026gt;Increment Async Manually\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;updateMsgManually(\u0026#39;Async new message\u0026#39;)\u0026#34;\u0026gt;Update Message Async Manually\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { // 手动定义方法来分发 action incrementAsyncManually() { // 手动调用 $store.dispatch，并传递 payload 对象 this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;, { amount: 10, delay: 500 }); }, updateMsgManually(newMessage) { // 手动调用 $store.dispatch this.$store.dispatch(\u0026#39;updateMessage\u0026#39;, newMessage); } } }; \u0026lt;/script\u0026gt; 注释说明:\nincrementAsyncManually 方法通过 this.$store.dispatch 分发 incrementAsync action，并传递包含 amount 和 delay 的 payload 对象。 updateMsgManually 方法分发 updateMessage action。 ✅ 用了 mapActions 使用 mapActions 可以将 actions 映射为组件的 methods。\n1. 传递字符串数组：\n当映射的方法名与 action 名相同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Message: {{ $store.state.message }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;incrementAsync({ amount: 3, delay: 1500 })\u0026#34;\u0026gt;Increment Async\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;updateMessage(\u0026#39;Hello from mapActions!\u0026#39;)\u0026#34;\u0026gt;Update Message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapActions } from \u0026#39;vuex\u0026#39;; export default { methods: { // 使用 mapActions 辅助函数将 store 中的 actions 映射到局部方法 ...mapActions([ \u0026#39;incrementAsync\u0026#39;, // 映射 this.incrementAsync() 为 this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;) \u0026#39;updateMessage\u0026#39; // 映射 this.updateMessage() 为 this.$store.dispatch(\u0026#39;updateMessage\u0026#39;) ]) // 调用 this.incrementAsync(payload) 等同于 this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;, payload) } }; \u0026lt;/script\u0026gt; 注释说明:\nmapActions(['incrementAsync', 'updateMessage']) 将 incrementAsync 和 updateMessage actions 映射为组件的同名方法。 调用 this.incrementAsync({ amount: 3, delay: 1500 }) 时，该对象会作为 payload 传递给 incrementAsync action。 2. 传递对象：\n当映射的方法名与 action 名不同时。\n代码段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;addAsync({ amount: 7 })\u0026#34;\u0026gt;Add to Count Async\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;modifyMessage(\u0026#39;Asynchronously changed message!\u0026#39;)\u0026#34;\u0026gt;Modify App Message Async\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { mapActions } from \u0026#39;vuex\u0026#39;; export default { methods: { ...mapActions({ addAsync: \u0026#39;incrementAsync\u0026#39;, // 将 this.addAsync() 映射为 this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;) modifyMessage: \u0026#39;updateMessage\u0026#39; // 将 this.modifyMessage() 映射为 this.$store.dispatch(\u0026#39;updateMessage\u0026#39;) }) // 调用 this.addAsync(payload) 等同于 this.$store.dispatch(\u0026#39;incrementAsync\u0026#39;, payload) } }; \u0026lt;/script\u0026gt; 注释说明:\naddAsync: 'incrementAsync' 将组件的 addAsync 方法映射到名为 incrementAsync 的 action。调用 this.addAsync({ amount: 7 }) 实际上是执行 this.$store.dispatch('incrementAsync', { amount: 7 })。 总结一下，Vuex 的辅助函数 (mapState, mapGetters, mapActions, mapMutations) 大大简化了在 Vue 组件中与 store 的交互，使得代码更加简洁、易读和易于维护。它们通过将 store 的属性和方法直接映射到组件的 computed 和 methods 中，减少了模板和脚本中的冗余代码。\n","date":"2025-05-31T16:48:58+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/vuex-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","title":"Vuex 四大核心辅助函数详解"},{"content":"SpringBoot原理学习笔记 一、配置优先级 1. 配置文件优先级 SpringBoot支持三种配置文件格式：\napplication.properties application.yml application.yaml 优先级从高到低：\nproperties \u0026gt; yml \u0026gt; yaml 推荐统一使用yml格式 2. 外部配置方式 除了配置文件，还支持：\nJava系统属性：-Dkey=value 命令行参数：--key=value 五种配置方式优先级： 命令行参数 \u0026gt; 系统属性 \u0026gt; properties \u0026gt; yml \u0026gt; yaml\n3. 打包后配置 运行jar包时指定参数：\n1 java -Dserver.port=9000 -jar XXXX.jar --server.port=10010 二、Bean管理 1. Bean作用域 Spring支持五种作用域：\nsingleton（默认）：单例 prototype：每次使用创建新实例 request（web）：每次HTTP请求 session（web）：每个HTTP会话 application（web）：整个Web应用生命周期 使用@Scope注解配置：\n1 2 3 @Scope(\u0026#34;prototype\u0026#34;) @RestController public class MyController {...} 2. 第三方Bean管理 当引入第三方依赖时，无法使用@Component注解，需要使用@Bean：\n方式1：在启动类中声明\n1 2 3 4 5 6 7 @SpringBootApplication public class App { @Bean public ThirdPartyBean thirdPartyBean() { return new ThirdPartyBean(); } } 方式2（推荐）：使用配置类\n1 2 3 4 5 6 7 @Configuration public class ThirdPartyConfig { @Bean public ThirdPartyBean thirdPartyBean() { return new ThirdPartyBean(); } } 三、SpringBoot原理 1. 起步依赖原理 通过Maven的依赖传递实现 如spring-boot-starter-web会自动引入web开发所需的所有依赖 简化了依赖管理 2. 自动配置原理 核心注解@SpringBootApplication包含：\n@SpringBootConfiguration：标识为配置类 @ComponentScan：组件扫描 @EnableAutoConfiguration：自动配置核心 自动配置流程：\n通过@Import(AutoConfigurationImportSelector.class)导入配置 AutoConfigurationImportSelector读取META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件 加载文件中定义的配置类 配置类中通过@Bean声明bean 3. 条件装配 使用@Conditional系列注解控制bean的注册：\n常用条件注解：\n@ConditionalOnClass：存在指定类时注册 @ConditionalOnMissingBean：不存在指定bean时注册 @ConditionalOnProperty：配置文件中存在指定属性时注册 4. 自定义Starter 标准结构：\nxxx-spring-boot-starter：依赖管理 xxx-spring-boot-autoconfigure：自动配置 实现步骤：\n创建starter模块管理依赖 创建autoconfigure模块实现自动配置 在autoconfigure中： 定义配置类用@Bean声明bean 在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports中注册配置类 示例：阿里云OSS Starter\nstarter模块pom引入autoconfigure autoconfigure模块： 定义AliyunOSSProperties保存配置 定义AliyunOSSOperator工具类 创建AliyunOSSAutoConfiguration配置类 1 2 3 4 5 6 7 8 @Configuration @EnableConfigurationProperties(AliyunOSSProperties.class) public class AliyunOSSAutoConfiguration { @Bean public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties properties) { return new AliyunOSSOperator(properties); } } 创建META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件指定配置类 使用：\n引入starter依赖 配置application.yml 直接注入使用： 1 2 @Autowired private AliyunOSSOperator aliyunOSSOperator; 总结 SpringBoot通过起步依赖简化依赖管理 通过自动配置简化bean配置 理解原理后可以自定义starter复用通用组件 条件装配使配置更加灵活智能 ","date":"2025-05-26T12:50:36+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/springboot%E5%8E%9F%E7%90%86/","title":"SpringBoot原理"},{"content":"Spring拦截器(Interceptor)学习笔记 一、拦截器概述 1.1 什么是拦截器？ 拦截器是Spring框架提供的一种动态拦截方法调用的机制，类似于Servlet中的过滤器(Filter)。主要特点包括：\n动态拦截控制器方法的执行 在指定方法调用前后执行预设代码 用于处理通用性的业务逻辑（如登录校验、权限检查、日志记录等） 1.2 拦截器 vs 过滤器 特性 拦截器(Interceptor) 过滤器(Filter) 所属框架 Spring MVC Servlet规范 拦截范围 只拦截Spring环境中的资源 拦截所有资源 依赖 依赖Spring容器 不依赖任何框架 执行时机 Controller方法前后 Servlet处理前后 实现接口 HandlerInterceptor Filter 二、拦截器快速入门 2.1 实现步骤 定义拦截器：实现HandlerInterceptor接口 注册配置：通过WebMvcConfigurer配置 2.2 代码实现 1) 自定义拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Component public class DemoInterceptor implements HandlerInterceptor { // 目标方法执行前调用 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle执行...\u0026#34;); return true; // true放行，false拦截 } // 目标方法执行后调用（视图渲染前） @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle执行...\u0026#34;); } // 整个请求完成后调用（视图渲染后） @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion执行...\u0026#34;); } } 2) 注册拦截器 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private DemoInterceptor demoInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(demoInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;); // 拦截所有路径 } } 2.3 执行顺序验证 当访问一个Controller方法时，控制台输出：\n1 2 3 4 preHandle执行... Controller方法执行... postHandle执行... afterCompletion执行... 注意：如果preHandle返回false，则后续流程都不会执行！\n三、登录校验拦截器实战 3.1 令牌校验实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Slf4j @Component public class TokenInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1. 获取请求URL String url = request.getRequestURL().toString(); // 2. 登录请求直接放行 if(url.contains(\u0026#34;login\u0026#34;)) { log.info(\u0026#34;登录请求，放行\u0026#34;); return true; } // 3. 获取token String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 4. token不存在返回未登录 if(!StringUtils.hasLength(jwt)) { log.error(\u0026#34;令牌为空\u0026#34;); response.setStatus(HttpStatus.SC_UNAUTHORIZED); // 401 return false; } // 5. 解析token try { JwtUtils.parseJWT(jwt); } catch (Exception e) { log.error(\u0026#34;令牌解析失败\u0026#34;); response.setStatus(HttpStatus.SC_UNAUTHORIZED); return false; } // 6. 放行 log.info(\u0026#34;令牌校验通过\u0026#34;); return true; } } 3.2 配置拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private TokenInterceptor tokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(tokenInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;) .excludePathPatterns(\u0026#34;/login\u0026#34;); // 排除登录接口 } } 四、拦截器详解 4.1 拦截路径配置 1) 基本配置方法 addPathPatterns()：添加拦截路径 excludePathPatterns()：添加排除路径 1 2 3 registry.addInterceptor(interceptor) .addPathPatterns(\u0026#34;/**\u0026#34;) // 拦截所有 .excludePathPatterns(\u0026#34;/login\u0026#34;); // 排除登录 2) 常见路径模式 模式 说明 /* 一级路径（如/user） /** 任意级路径（如/user/1） /admin/** 拦截/admin下的所有路径 /secure/*.do 拦截/secure下的所有.do请求 4.2 拦截器执行流程 完整请求生命周期 过滤器前置处理 DispatcherServlet接收请求 拦截器preHandle 返回true：继续执行 返回false：终止流程 Controller方法执行 拦截器postHandle 视图渲染 拦截器afterCompletion 过滤器后置处理 执行流程图 五、最佳实践建议 登录校验：推荐使用拦截器而非过滤器\n能利用Spring的依赖注入 更精准控制Spring环境中的请求 路径配置：\n1 2 3 4 // 推荐配置方式 registry.addInterceptor(authInterceptor) .addPathPatterns(\u0026#34;/api/**\u0026#34;) .excludePathPatterns(\u0026#34;/api/public/**\u0026#34;); 性能优化：\n在preHandle中进行轻量级检查 避免在拦截器中执行耗时操作 多拦截器顺序：\n通过order()方法控制执行顺序 1 2 registry.addInterceptor(interceptor1).order(1); registry.addInterceptor(interceptor2).order(2); 六、常见问题解答 Q1：拦截器和过滤器如何选择？\n需要处理Spring相关功能（如自动注入、AOP等）→ 拦截器 需要处理静态资源、非Spring请求 → 过滤器 Q2：拦截器能获取Controller方法信息吗？ 可以，通过handler参数：\n1 2 3 4 5 if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); // 可以获取方法注解等信息 } Q3：拦截器中如何修改响应数据？ 可以在postHandle中操作ModelAndView：\n1 2 3 4 @Override public void postHandle(...) { modelAndView.addObject(\u0026#34;newData\u0026#34;, \u0026#34;value\u0026#34;); } ","date":"2025-05-24T13:33:57+08:00","image":"https://wp-cdn.4ce.cn/v2/i7r99m2.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-interceptor%E6%8B%A6%E6%88%AA%E5%99%A8/","title":"Web开发-Interceptor拦截器"},{"content":"深入理解异常的抛出与处理 一、异常的抛出 （一）系统自动抛出异常 在程序执行过程中，当遇到一些不符合语言规则或者逻辑错误的情况时，Java 系统会自动抛出异常。例如，进行整数除法运算时，如果除数为 0，系统就会自动抛出 ArithmeticException 异常。\n1 2 3 4 5 6 public class AutoThrowException { public static void main(String[] args) { int result = 10 / 0; // 这里系统会自动抛出ArithmeticException异常 System.out.println(\u0026#34;结果是: \u0026#34; + result); } } 在上述代码中，10 / 0 这一操作不符合数学运算规则，Java 系统检测到这个错误后，会自动创建一个 ArithmeticException 异常对象并抛出。此时，程序的正常执行流程被打断，不会继续执行 System.out.println(\u0026quot;结果是: \u0026quot; + result); 这一行代码。\n（二）手动抛出异常 有时候，根据业务逻辑的需要，程序员需要手动抛出异常。这通过 throw 关键字来实现。例如，在一个用户注册功能中，要求用户名不能为空。如果检测到用户名为空，就可以手动抛出一个自定义异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class UsernameEmptyException extends RuntimeException { public UsernameEmptyException(String message) { super(message); } } public class ManualThrowException { public static void registerUser(String username) { if (username == null || username.isEmpty()) { throw new UsernameEmptyException(\u0026#34;用户名不能为空\u0026#34;); } System.out.println(\u0026#34;用户 \u0026#34; + username + \u0026#34; 注册成功\u0026#34;); } public static void main(String[] args) { try { registerUser(\u0026#34;\u0026#34;); } catch (UsernameEmptyException e) { System.out.println(\u0026#34;捕获到异常: \u0026#34; + e.getMessage()); } } } 在 registerUser 方法中，通过 if 语句检查用户名是否为空。如果为空，使用 throw 关键字手动抛出一个 UsernameEmptyException 异常对象。这个异常对象携带了 “用户名不能为空” 这一错误信息。\n二、异常的声明抛出 当一个方法内部可能会抛出某种异常，但该方法本身不处理这个异常，而是希望调用它的方法来处理时，就需要在方法声明中使用 throws 关键字声明该方法可能抛出的异常类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.io.FileNotFoundException; import java.io.FileReader; public class DeclareThrowException { // 声明该方法可能抛出FileNotFoundException异常 public static void readFile(String filePath) throws FileNotFoundException { FileReader fileReader = new FileReader(filePath); // 如果文件不存在，FileReader构造函数会抛出FileNotFoundException异常 } public static void main(String[] args) { try { readFile(\u0026#34;nonexistentfile.txt\u0026#34;); } catch (FileNotFoundException e) { System.out.println(\u0026#34;文件不存在异常: \u0026#34; + e.getMessage()); } } } 在 readFile 方法中，FileReader 的构造函数可能会因为文件不存在而抛出 FileNotFoundException 异常。由于 readFile 方法不处理这个异常，所以在方法声明处使用 throws FileNotFoundException 声明。这样，调用 readFile 方法的代码（如 main 方法）就需要处理这个可能抛出的异常，否则会导致编译错误。\n三、异常的捕获与处理 为了避免异常导致程序终止运行，需要使用 try - catch 块来捕获并处理异常。\n（一）基本的 try - catch 结构 1 2 3 4 5 6 7 8 9 10 11 public class BasicTryCatch { public static void main(String[] args) { try { int[] numbers = {1, 2, 3}; System.out.println(numbers[3]); // 这里会抛出ArrayIndexOutOfBoundsException异常 } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;捕获到数组越界异常: \u0026#34; + e.getMessage()); } System.out.println(\u0026#34;程序继续执行...\u0026#34;); } } 在 try 块中放置可能会抛出异常的代码。如果 try 块中的代码抛出了 ArrayIndexOutOfBoundsException 异常，程序会立即跳转到对应的 catch 块中执行。catch 块中的参数 e 是捕获到的异常对象，可以通过它获取异常的相关信息，如错误消息。处理完 catch 块中的代码后，程序会继续执行 try - catch 块之后的代码。\n（二）多重 catch 块 当 try 块中的代码可能抛出多种不同类型的异常时，可以使用多个 catch 块来分别处理不同类型的异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MultipleCatch { public static void main(String[] args) { try { int result = 10 / 0; // 可能抛出ArithmeticException异常 int[] numbers = {1, 2, 3}; System.out.println(numbers[3]); // 可能抛出ArrayIndexOutOfBoundsException异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;捕获到算术异常: \u0026#34; + e.getMessage()); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\u0026#34;捕获到数组越界异常: \u0026#34; + e.getMessage()); } System.out.println(\u0026#34;程序继续执行...\u0026#34;); } } 在这个例子中，try 块中的代码既有可能抛出 ArithmeticException 异常（除法运算中除数为 0），也有可能抛出 ArrayIndexOutOfBoundsException 异常（数组越界访问）。每个 catch 块负责处理特定类型的异常，程序会根据实际抛出的异常类型跳转到对应的 catch 块执行。\n（三）finally 块 finally 块通常与 try - catch 块一起使用，无论 try 块中是否抛出异常，也无论异常是否被 catch 块捕获，finally 块中的代码都会被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class FinallyBlock { public static void main(String[] args) { try { int result = 10 / 2; System.out.println(\u0026#34;结果是: \u0026#34; + result); } catch (ArithmeticException e) { System.out.println(\u0026#34;捕获到算术异常: \u0026#34; + e.getMessage()); } finally { System.out.println(\u0026#34;finally块总是会执行\u0026#34;); } System.out.println(\u0026#34;程序继续执行...\u0026#34;); } } 在上述代码中，try 块正常执行没有抛出异常，但 finally 块中的代码依然会被执行。如果 try 块中抛出了异常并且被 catch 块捕获，finally 块同样会在 catch 块执行完毕后执行。\n通过理解异常的抛出、声明抛出以及捕获处理机制，可以更好地编写健壮的 Java 程序，使其能够应对各种可能出现的错误情况，提高程序的稳定性和可靠性。\n","date":"2025-05-22T16:31:27+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/java%E5%9F%BA%E7%A1%80%E7%AF%87-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E4%B8%8E%E5%A4%84%E7%90%86/","title":"Java基础篇-深入理解异常的抛出与处理"},{"content":"Spring 中事务失效场景学习笔记 在 Spring 开发中，事务管理是保证数据一致性和完整性的重要手段，但在某些场景下事务会失效。以下是常见的事务失效场景及其分析：\n一、异常捕获处理 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Transactional public void update(Integer from, Integer to, Double money) { try { // 转账的用户不能为空 Account fromAccount = accountDao.selectById(from); // 判断用户的钱是否够转账 if (fromAccount.getMoney() - money \u0026gt;= 0) { fromAccount.setMoney(fromAccount.getMoney() - money); accountDao.updateById(fromAccount); // 异常 int a = 1/0; // 被转账的用户 Account toAccount = accountDao.selectById(to); toAccount.setMoney(toAccount.getMoney() + money); accountDao.updateById(toAccount); } } catch (Exception e) { e.printStackTrace(); } } 失效原因 事务通知只有捕捉到目标抛出的异常，才能进行后续的回滚处理。如果目标自己处理掉异常，事务通知无法知悉，事务不会回滚，从而导致事务失效。\n解决方案 在 catch 块添加throw new RuntimeException(e)抛出异常，让事务通知能够捕捉到异常进行回滚。\n二、抛出检查异常 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Transactional public void update(Integer from, Integer to, Double money) throws FileNotFoundException { // 转账的用户不能为空 Account fromAccount = accountDao.selectById(from); // 判断用户的钱是否够转账 if (fromAccount.getMoney() - money \u0026gt;= 0) { fromAccount.setMoney(fromAccount.getMoney() - money); accountDao.updateById(fromAccount); // 读取文件 new FileInputStream(\u0026#34;dddd\u0026#34;); // 被转账的用户 Account toAccount = accountDao.selectById(to); toAccount.setMoney(toAccount.getMoney() + money); accountDao.updateById(toAccount); } } 失效原因 Spring 默认只会回滚非检查异常（继承自RuntimeException及其子类），对于检查异常（如FileNotFoundException 等受检异常），默认情况下不会触发事务回滚，导致事务失效。\n解决方案 配置rollbackFor属性，在@Transactional注解中指定rollbackFor=Exception.class ，这样 Spring 就会对指定的异常类型进行事务回滚。\n三、非 public 方法 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Transactional(rollbackFor = Exception.class) void update(Integer from, Integer to, Double money) throws FileNotFoundException { // 转账的用户不能为空 Account fromAccount = accountDao.selectById(from); // 判断用户的钱是否够转账 if (fromAccount.getMoney() - money \u0026gt;= 0) { fromAccount.setMoney(fromAccount.getMoney() - money); accountDao.updateById(fromAccount); // 读取文件 new FileInputStream(\u0026#34;dddd\u0026#34;); // 被转账的用户 Account toAccount = accountDao.selectById(to); toAccount.setMoney(toAccount.getMoney() + money); accountDao.updateById(toAccount); } } 失效原因 Spring 为方法创建代理、添加事务通知等操作的前提条件是该方法是public的。如果方法不是public ，Spring 的事务管理机制无法正常工作，导致事务失效。\n解决方案 将方法的访问修饰符改为public ，确保 Spring 能够正确地为其添加事务通知并进行事务管理。\n掌握这些事务失效场景及其解决方案，有助于在 Spring 项目开发中更好地进行事务管理，保证业务逻辑的数据一致性和完整性。\n","date":"2025-05-22T16:23:06+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spirng%E7%AF%87-spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF/","title":"Spirng篇-Spring中事务失效的场景"},{"content":"Filter过滤器学习笔记 一、Filter概述 1.1 什么是Filter Filter（过滤器）是JavaWeb三大组件之一（Servlet、Filter、Listener），主要用于拦截请求并实现一些通用功能：\n拦截特性：所有对Web服务器资源的请求都必须先经过过滤器 常见用途： ✅ 登录校验 ✅ 统一编码处理 ✅ 敏感字符过滤 ✅ 权限控制 1.2 工作原理图解 二、Filter快速入门 2.1 基础实现步骤 1. 定义过滤器类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) // 拦截所有请求 public class DemoFilter implements Filter { // 初始化方法（服务器启动时调用一次） @Override public void init(FilterConfig filterConfig) { System.out.println(\u0026#34;过滤器初始化...\u0026#34;); } // 核心过滤方法（每次请求都会调用） @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;拦截到请求...\u0026#34;); // 关键放行操作！没有这行代码请求将被阻塞 chain.doFilter(request, response); } // 销毁方法（服务器关闭时调用一次） @Override public void destroy() { System.out.println(\u0026#34;过滤器销毁...\u0026#34;); } } 2. 启用Servlet组件扫描 1 2 3 4 5 6 7 @ServletComponentScan // 必须添加！启用Servlet组件支持 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 2.2 注意事项 ⚠️ 必须调用chain.doFilter()：否则请求会被拦截，无法继续后续处理\n⚠️ @ServletComponentScan注解：忘记添加会导致过滤器不生效\n三、登录校验过滤器实战 3.1 设计思路 3.2 完整实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class TokenFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; // 1. 获取请求URL String url = request.getRequestURL().toString(); log.info(\u0026#34;请求URL: {}\u0026#34;, url); // 2. 登录请求直接放行 if(url.contains(\u0026#34;login\u0026#34;)) { chain.doFilter(request, response); return; } // 3. 获取Token String jwt = request.getHeader(\u0026#34;token\u0026#34;); // 4. Token为空处理 if(!StringUtils.hasLength(jwt)) { response.setStatus(HttpStatus.SC_UNAUTHORIZED); response.getWriter().write(\u0026#34;未携带令牌！\u0026#34;); return; } // 5. 验证Token有效性 try { JwtUtils.parseJWT(jwt); // 解析验证 } catch (Exception e) { response.setStatus(HttpStatus.SC_UNAUTHORIZED); response.getWriter().write(\u0026#34;无效令牌！\u0026#34;); return; } // 6. 验证通过，放行 chain.doFilter(request, response); } } 3.3 测试场景 测试场景 预期结果 未登录访问受限资源 自动跳转登录页 登录后访问资源 正常响应 Token过期访问 返回401错误 四、Filter高级特性 4.1 完整执行流程 1 2 3 4 5 6 7 8 9 10 public void doFilter(...) { // 1. 前置处理逻辑 System.out.println(\u0026#34;前置处理...\u0026#34;); // 2. 关键放行操作 chain.doFilter(request, response); // 3. 后置处理逻辑 System.out.println(\u0026#34;后置处理...\u0026#34;); } 执行顺序：\n前置处理 -\u0026gt; 资源访问 -\u0026gt; 后置处理\n4.2 拦截路径配置 配置方式 示例 说明 全部拦截 /* 拦截所有请求 路径拦截 /user/* 拦截/user下的所有请求 后缀拦截 *.jsp 拦截所有jsp页面 精确拦截 /login 只拦截/login请求 4.3 过滤器链 当存在多个过滤器时：\n执行顺序：按照类名自然排序（如AbcFilter先于DemoFilter） 执行流程： 五、最佳实践建议 性能优化：\n在init()方法中初始化耗时资源 避免在doFilter()中进行复杂计算 异常处理：\n1 2 3 4 5 6 try { chain.doFilter(request, response); } catch (Exception e) { // 统一异常处理 response.sendError(500, \u0026#34;服务器错误\u0026#34;); } 实用技巧：\n使用@Order注解控制过滤器顺序（Spring环境下） 通过FilterConfig获取初始化参数 常见问题：\n❌ 忘记调用chain.doFilter() ❌ 未添加@ServletComponentScan ❌ 在过滤器中抛出未处理异常 通过本学习笔记，可以全面掌握Filter的核心概念和实际应用，特别是在登录校验等安全场景下的关键作用。建议结合实际项目进行练习，加深理解。\n","date":"2025-05-22T16:03:10+08:00","image":"https://wp-cdn.4ce.cn/v2/xEZSlj4.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-filter%E8%BF%87%E6%BB%A4%E5%99%A8/","title":"Web开发-Filter过滤器"},{"content":"JWT令牌技术学习笔记 一、令牌技术概述 1. 令牌本质 本质：令牌是用户身份的标识，实质是一个字符串 作用：用于会话跟踪，作为用户合法身份凭证 2. 工作流程 登录阶段\n✅ 登录成功 → 生成令牌 → 返回给前端 存储阶段\n📦 前端存储令牌（Cookie/LocalStorage） 请求阶段\n🔄 每次请求携带令牌 → 服务端校验有效性 3. 核心特点 优点 支持PC/移动端 解决集群认证问题 无服务端存储压力 缺点 需自主实现生成/传递/校验逻辑 二、JWT令牌详解 1. JWT核心概念 全称：JSON Web Token\n官网：https://jwt.io/\n三大特性：\n🎯 简洁：简单字符串，可直接通过请求头/参数传递 📦 自包含：可存储自定义数据（如用户信息） 🔒 安全：基于数字签名防篡改 2. JWT组成结构 部分 名称 内容示例 作用 Header 头 {\u0026quot;alg\u0026quot;:\u0026quot;HS256\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;JWT\u0026quot;} 声明算法和令牌类型 Payload 有效载荷 {\u0026quot;id\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;username\u0026quot;:\u0026quot;Tom\u0026quot;} 携带自定义/默认信息 Signature 签名 对Header+Payload的加密签名 防篡改保安全 ✨ 三部分用.连接：Header.Payload.Signature\n3. Base64编码 作用：将JSON数据转为字符串 特点： 使用64个可打印字符（A-Z, a-z, 0-9, +, /） =为补位符号 ❗ 注意：是编码方式而非加密！ 三、JWT实战开发 1. 生成与校验流程 2. 代码实现 🔧 依赖引入 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 🛠️ 核心工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class JwtUtils { private static String signKey = \u0026#34;SVRIRUlNQQ==\u0026#34;; private static Long expire = 43200000L; // 生成令牌 public static String generateJwt(Map\u0026lt;String,Object\u0026gt; claims){ return Jwts.builder() .addClaims(claims) .signWith(SignatureAlgorithm.HS256, signKey) .setExpiration(new Date(System.currentTimeMillis() + expire)) .compact(); } // 解析令牌 public static Claims parseJWT(String jwt){ return Jwts.parser() .setSigningKey(signKey) .parseClaimsJws(jwt) .getBody(); } } 🔑 登录成功生成令牌 1 2 3 4 5 6 7 8 9 10 11 12 13 @Override public LoginInfo login(Emp emp) { Emp empLogin = empMapper.getByUsernameAndPassword(emp); if(empLogin != null){ Map\u0026lt;String,Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, empLogin.getId()); claims.put(\u0026#34;username\u0026#34;, empLogin.getUsername()); String jwt = JwtUtils.generateJwt(claims); // 生成令牌 return new LoginInfo(..., jwt); // 返回给前端 } return null; } 3. 安全注意事项 签名密钥：必须与生成时一致 篡改检测：任何字符修改都会导致校验失败 过期控制：通过setExpiration设置有效期 1 .setExpiration(new Date(System.currentTimeMillis() + 60 * 1000)) // 60秒过期 四、企业应用场景 🌟 典型登录认证流程 用户登录 → 服务端生成JWT → 返回前端 前端存储JWT（LocalStorage） 每次请求携带JWT（Authorization头） 服务端拦截校验： 无令牌 → 拒绝访问 ❌ 无效令牌 → 拒绝访问 ❌ 有效令牌 → 放行 ✅ 📊 传统方案 vs JWT方案 方案 跨端支持 集群适配 服务端压力 实现复杂度 Cookie 有限 不友好 高 低 Session 有限 不友好 高 中 JWT ✅ 强 ✅ 强 ❗ 无 需自主实现 🚀 现代开发首选：JWT已成为主流会话跟踪方案\n五、重点总结 JWT三大优势：\n✔️ 跨平台 ✔️ 无状态 ✔️ 自包含数据 安全核心：\n🔐 签名机制确保不可篡改 开发关键： 令牌生成时设置合理有效期 前端需妥善存储（防XSS攻击） 服务端统一拦截校验 调试工具：\n🔍 使用jwt.io解码验证令牌 📌 黄金法则：任何令牌修改都会导致校验失败，这是JWT安全性的基石！\n","date":"2025-05-22T14:59:59+08:00","image":"https://wp-cdn.4ce.cn/v2/ReUH0WH.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-jwt%E4%BB%A4%E7%89%8C%E6%8A%80%E6%9C%AF/","title":"Web开发-JWT令牌技术"},{"content":"Session 会话跟踪技术学习笔记 一、Session 基本概念 本质：服务器端会话跟踪技术，存储在服务端 底层实现：基于 Cookie 机制实现 二、Session 工作流程 1. 获取Session 首次请求时：\n服务器检查是否存在Session对象 不存在则自动创建新Session对象 每个Session对象都有唯一ID（如示意图中的Session(1)） 关键点：Session对象由服务器自动创建维护\n2. 响应Cookie (JSESSIONID) 响应阶段：\n服务器通过响应头Set-Cookie返回Session ID 固定Cookie名：JSESSIONID=会话ID值 浏览器自动存储该Cookie 1 2 HTTP/1.1 200 OK Set-Cookie: JSESSIONID=123456789 3. 查找Session 后续请求时：\n浏览器自动携带JSESSIONID Cookie 服务器通过ID查找对应Session对象 实现同会话多次请求间的数据共享 三、代码测试验证 测试接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Slf4j @RestController public class SessionController { // 存储数据到Session @GetMapping(\u0026#34;/s1\u0026#34;) public Result session1(HttpSession session){ session.setAttribute(\u0026#34;loginUser\u0026#34;, \u0026#34;tom\u0026#34;); return Result.success(); } // 从Session获取数据 @GetMapping(\u0026#34;/s2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); Object loginUser = session.getAttribute(\u0026#34;loginUser\u0026#34;); return Result.success(loginUser); } } 测试结果 首次访问/s1：\n响应头出现 Set-Cookie: JSESSIONID=xxx 服务器创建新Session 后续访问/s2：\n请求头携带 Cookie: JSESSIONID=xxx 验证成功： 两次请求获取的Session对象hashcode相同 能正确获取之前存储的loginUser数据 四、Session的优缺点 ✅ 优点 安全性高：数据存储在服务端 ❌ 缺点 集群环境失效：多台服务器间Session不共享 移动端限制：Android/IOS无法使用Cookie 用户行为影响： 可能禁用Cookie Cookie有跨域限制 核心问题：Session依赖Cookie机制，当Cookie不可用时整个方案失效\n五、集群环境问题详解 典型部署架构 1 用户 -\u0026gt; 负载均衡服务器 -\u0026gt; [Tomcat1, Tomcat2, Tomcat3] 问题场景 用户登录请求被路由到Tomcat1\n创建SessionA（ID=123） 查询请求被路由到Tomcat2\n携带JSESSIONID=123 但Tomcat2不存在该Session → 会话中断 根本原因 Session数据未在集群间同步，导致：\n同一用户多次请求可能访问不同服务器 各服务器Session存储相互独立 ","date":"2025-05-22T14:46:24+08:00","image":"https://wp-cdn.4ce.cn/v2/lBctlux.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-session%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF/","title":"Web开发-Session会话跟踪技术"},{"content":"Cookie 学习笔记 1. Cookie 基本概念 Cookie 是一种客户端会话跟踪技术，数据存储在客户端浏览器中。主要用于在同一次会话的不同请求之间共享数据。\n2. Cookie 工作流程 第一次请求：客户端访问服务器（如登录接口） 服务器响应：在响应中设置Cookie（包含用户ID、用户名等信息） 浏览器存储：自动将Cookie保存到本地 后续请求：浏览器自动携带该Cookie到服务器 三个关键\u0026quot;自动\u0026quot;： ✅ 服务器自动通过Set-Cookie响应头返回Cookie ✅ 浏览器自动存储接收到的Cookie ✅ 后续请求浏览器自动通过Cookie请求头携带Cookie 3. HTTP 协议支持 类型 头字段 说明 响应头 Set-Cookie 服务器设置Cookie 请求头 Cookie 客户端携带Cookie 4. 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 设置Cookie @GetMapping(\u0026#34;/c1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_username\u0026#34;,\u0026#34;itheima\u0026#34;)); return Result.success(); } // 获取Cookie @GetMapping(\u0026#34;/c2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) { if(cookie.getName().equals(\u0026#34;login_username\u0026#34;)){ System.out.println(\u0026#34;login_username: \u0026#34;+cookie.getValue()); } } return Result.success(); } 5. 测试流程 访问/c1接口 → 服务器设置Cookie → 浏览器存储\n访问/c2接口 → 浏览器自动携带Cookie → 服务器读取\n6. 优缺点分析 ✅ 优点： HTTP协议原生支持（浏览器自动处理） 实现简单 ❌ 缺点： 移动端兼容性问题 Android/iOS原生APP无法使用 安全性问题 用户可以手动禁用Cookie 存在CSRF风险 跨域限制 无法在不同域之间共享Cookie 7. 跨域详解 跨域判定标准（任一不同即为跨域）： 维度 示例1 示例2 是否跨域 协议 http https ✔️ IP 192.168.150.200 192.168.150.100 ✔️ 端口 80 8080 ✔️ 典型跨域场景： 1 2 前端：http://192.168.150.200/login.html 后端：http://192.168.150.100:8080/login ⚠️ 此时设置的Cookie无法跨域使用\n8. 关键总结 Cookie是基于HTTP协议的会话管理技术 自动管理机制由浏览器实现 适合同域的Web应用，但在移动端和跨域场景下受限 重要数据应考虑配合其他安全措施使用 提示：现代Web开发中，对于身份认证等敏感场景，建议结合Token等更安全的技术方案。\n","date":"2025-05-22T14:29:11+08:00","image":"https://wp-cdn.4ce.cn/v2/H5jyJHn.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-cookie/","title":"Web开发-Cookie"},{"content":"Web开发会话技术学习笔记 一、会话基础概念 1.1 什么是会话？ 定义：浏览器与服务器的一次连接称为会话（从第一次访问到任意一方断开连接） 特点： 包含多次请求和响应（如：登录→查询部门→查询员工） 浏览器关联性：同一浏览器多次请求属于同一会话 多浏览器访问会创建多个独立会话 1.2 会话跟踪 核心需求：识别多次请求是否来自同一浏览器 技术本质：在HTTP无状态协议下实现数据共享 典型场景：登录状态维持、购物车数据同步 二、会话跟踪三大方案对比 2.1 Cookie（客户端存储） 工作流程 服务端通过Set-Cookie响应头设置数据 浏览器自动存储Cookie 后续请求自动通过Cookie请求头携带 代码示例 1 2 3 4 5 6 7 8 // 设置Cookie response.addCookie(new Cookie(\u0026#34;login_user\u0026#34;, \u0026#34;alice\u0026#34;)); // 读取Cookie Arrays.stream(request.getCookies()) .filter(c -\u0026gt; \u0026#34;login_user\u0026#34;.equals(c.getName())) .findFirst() .ifPresent(c -\u0026gt; System.out.println(c.getValue())); 优缺点 ✅ 优点：\nHTTP协议原生支持（自动处理） ❌ 缺点：\n移动端兼容性差（Android/iOS限制） 安全性风险（用户可禁用/篡改） 跨域限制（协议/IP/端口任一不同即受限） 2.2 Session（服务端存储） 核心机制 基于Cookie传递JSESSIONID 会话数据实际存储在服务端 工作流程 首次请求创建Session对象（含唯一ID） 通过JSESSIONID Cookie返回ID 后续请求通过ID查找对应Session 代码示例 1 2 3 4 5 // 存储数据 session.setAttribute(\u0026#34;cart\u0026#34;, cartItems); // 获取数据 List\u0026lt;Item\u0026gt; items = (List\u0026lt;Item\u0026gt;)session.getAttribute(\u0026#34;cart\u0026#34;); 优缺点 ✅ 优点：\n数据存储在服务端，安全性较高 ❌ 致命缺点：\n集群环境失效（Session不共享） 依然依赖Cookie（继承Cookie所有缺点） 服务器内存压力大 2.3 令牌技术（主流方案） 核心特点 无状态：服务端不存储会话数据 自包含：用户信息/签名直接编码在令牌中 典型流程 优势亮点 ✅ 核心优势：\n完美支持移动端和跨域 天然适应集群环境 减轻服务器存储压力 ❌ 实现复杂度：\n需自行处理令牌的生成/传递/验证 需要选择安全的加密算法（如HS256/RSA） 三、企业级方案选型建议 传统Web项目：可考虑Session+Cookie（需解决集群问题） 前后端分离/移动端：必须使用令牌技术 高并发场景：JWT等无状态方案是首选 🔥 重点结论：现代Web开发中，令牌技术（如JWT）已成为会话跟踪的事实标准，其优势明显覆盖了传统方案的缺陷。\n","date":"2025-05-22T14:14:56+08:00","image":"https://wp-cdn.4ce.cn/v2/pyeLuoy.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/web%E5%BC%80%E5%8F%91-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","title":"Web开发-会话技术"},{"content":"SpringBoot+Mybatis 登录认证功能实现笔记 一、需求分析 核心目标：实现基于用户名密码的登录认证，保护系统后台安全。\n功能要点：\n✅ 用户输入用户名密码后验证 ✅ 验证成功：返回用户信息并跳转首页 ✅ 验证失败：提示错误信息 二、技术实现方案 1. 数据库设计 使用已有员工表emp作为认证数据源：\n1 2 3 4 5 6 CREATE TABLE emp ( id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL UNIQUE, -- 登录用户名 password VARCHAR(32) DEFAULT \u0026#39;123456\u0026#39; NOT NULL, -- MD5加密存储更安全 ... ); 2. 核心代码实现 2.1 实体类封装 1 2 3 4 5 6 7 8 9 @Data @NoArgsConstructor @AllArgsConstructor public class LoginInfo { private Integer id; // 员工ID private String username; // 登录账号 private String name; // 真实姓名 private String token; // 认证令牌（后续扩展） } 2.2 Controller层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController public class LoginController { @Autowired private EmpService empService; @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody Emp emp) { LoginInfo loginInfo = empService.login(emp); return loginInfo != null ? Result.success(loginInfo) : Result.error(\u0026#34;用户名或密码错误\u0026#34;); } } 2.3 Service层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Service public class EmpServiceImpl implements EmpService { @Override public LoginInfo login(Emp emp) { // 查询数据库验证 Emp dbEmp = empMapper.getByUsernameAndPassword( emp.getUsername(), emp.getPassword() ); return dbEmp != null ? new LoginInfo(dbEmp.getId(), dbEmp.getUsername(), dbEmp.getName(), null) : null; } } 2.4 Mapper层 1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { @Select(\u0026#34;SELECT * FROM emp WHERE username=#{username} AND password=#{password}\u0026#34;) Emp getByUsernameAndPassword( @Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password ); } 三、关键点说明 安全增强建议：\n🔒 密码应MD5加密存储（示例中为明文，实际项目需加密） 🛡️ 增加验证码防止暴力破解 ⏱️ 使用JWT替代简单token实现无状态认证 接口规范：\n请求方式：POST /login 请求参数：{\u0026quot;username\u0026quot;:\u0026quot;admin\u0026quot;, \u0026quot;password\u0026quot;:\u0026quot;123456\u0026quot;} 成功响应： 1 2 3 4 5 6 7 8 9 10 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;管理员\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;...\u0026#34; } } 四、测试验证 测试用例 测试场景 预期结果 正确用户名密码 返回200，包含用户信息 错误密码 返回错误提示 不存在的用户名 返回错误提示 API测试示例 1 2 3 4 5 6 7 POST http://localhost:8080/login Content-Type: application/json { \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34; } 五、扩展思考 会话管理：当前实现是简单认证，后续可引入： Spring Security框架 Redis存储会话信息 密码安全： 1 2 // 实际存储应加密 password = DigestUtils.md5Hex(password + salt); 日志审计：记录登录操作日志 六、总结 通过本次开发，我们实现了：\n基本的用户名密码认证流程 RESTful风格的登录接口 前后端分离的数据交互 重点注意：当前实现是基础版本，生产环境需要加强安全措施！\n","date":"2025-05-22T14:06:20+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/springboot-mybatis-%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","title":"SpringBoot+Mybatis 登录认证功能实现"},{"content":"Java基础 1、Java 的主要特性有哪些？ ●面向对象：支持封装、继承和多态等面向对象编程的基本概念。\n●平台无关性：编译后的字节码可以在任何支持Java的平台上运行，实现了“编写一次，到处运行”。\n●自动内存管理：通过垃圾回收机制自动管理内存，减轻程序员负担。\n●安全性高：提供了多种安全机制，如字节码验证、沙箱安全模型等。\n●多线程支持：内置了对多线程编程的支持，便于开发高性能应用。\n●丰富的API库：拥有大量的类库，涵盖了网络编程、数据库连接、图形用户界面设计等多个方面。\n2、public、private、protected、default的区别 修饰符 类内部 同包 子类 任何地方 public Yes Yes Yes Yes protected Yes Yes Yes default（包访问权限） Yes Yes private Yes 3、基本数据类型有哪些？每种类型的默认值是什么？ Java中的基本数据类型分为四类，共8种，它们分别用于表示整数、浮点数、字符和布尔值。这些基本数据类型都是Java语言的构建块，用于存储简单的值。\nJava基本数据类型的总结表\n数据类型 字节数 取值范围 默认值 byte 1 -128到127 0 short 2 -32,768到32,767 0 int 4 -231到231-1 0 long 8 -263到263-1 0L float 4 约为1.4E-45到3.4E+38 0.0f double 8 约为4.9E-324到1.8E+308 0.0d char 2 0到65,535 \u0026lsquo;\\u0000\u0026rsquo; boolean JVM定义 true或false false 重要提示❗ ❗ ❗ 1、默认值：以上默认值是指这些基本数据类型的实例变量（成员变量）在类中未被显式初始化时的默认值。在局部变量（如方法内部的变量）中，必须显式初始化后才能使用，否则编译会报错。 2、数据类型转换：在Java中，基本数据类型可以进行自动类型转换（从低精度到高精度，如int到long），但从高精度转换到低精度时需要进行显式类型转换（强制转换），否则可能会导致数据精度的丢失。\n4、解释面向对象编程的四大基本特征：封装、继承、多态和抽象。 ●封装：通过隐藏数据和实现细节，保护对象的状态。\n●继承：通过继承父类的属性和方法，实现代码的重用和扩展。\n●多态：通过方法重写和接口实现，允许同一方法在不同对象中表现出不同的行为。\n●抽象：通过抽象类和接口，提供统一的接口，隐藏实现细节，简化编程接口。\n5、接口和抽象类有什么区别？ ●接口：适合用来定义类的行为规范，强调“能做什么”（What to do）。它适合定义松散耦合的模块，允许多重实现。\n●抽象类：适合用来提供基础的功能和默认实现，强调“是什么”（What is it）。它更适合描述具有共同特性的一组类，并且允许部分代码重用。\n根据具体需求选择接口或抽象类，在设计和开发中实现代码的高内聚和低耦合。\n6、重载和重写的区别是什么？ ●重载：发生在同一类中，通过相同的方法名但不同的参数列表（参数的类型、数量或顺序）来实现。重载体现了编译时的多态性。\n●重写：发生在子类与父类之间，通过在子类中重新定义父类方法（该方法与父类中的方法具有相同的名称、参数列表和返回类型）来实现。重写体现了运行时的多态性。\n这两者提供了不同层面的多态性，使得Java程序可以更灵活地处理方法调用。\n7、什么是java序列化？或者请解释Serializable接口的作用 Java序列化是一种机制，通过将Java对象的状态转换为字节流，使其可以被存储或传输，并在需要时恢复（反序列化）为原始对象。序列化通常用于保存对象的状态以便后续恢复，或在网络中传输对象。\nSerializable接口的作用主要是标记一个类的对象可以被序列化。通过实现这个接口，Java的对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）就知道如何处理该对象的序列化和反序列化。注意，未标记为序列化的类对象在尝试序列化时会抛出NotSerializableException。\n此外，如果类中包含不想序列化的字段，可以使用transient关键字修饰这些字段，这样它们在序列化过程中将被忽略。\n8、Java程序是如何执行的？ Java程序的执行过程是一个多步骤的过程，从编写代码到程序的最终运行，包括编译、解释、执行等多个环节。以下是Java程序的执行步骤的详细描述：\n1. 编写Java源代码 首先，开发者在文本编辑器或集成开发环境（IDE）中编写Java源代码，并将其保存为.java文件。例如，下面是一个简单的Java程序：\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } 2. 编译Java源代码 在这一步，Java编译器（javac）将Java源代码编译成字节码（Bytecode）。字节码是一种中间表示形式，独立于特定的硬件和操作系统。编译后的字节码保存在.class文件中。\n1 javac HelloWorld.java 运行上面的命令后，将生成HelloWorld.class文件，这个文件包含了字节码。\n3. 加载字节码 当运行Java程序时，Java虚拟机（JVM）会启动，并由类加载器（Class Loader）将编译好的字节码加载到内存中。JVM中的类加载器系统负责动态地加载、链接和初始化类。\n4. 执行字节码 字节码被加载后，JVM中的解释器（Interpreter）或即时编译器（JIT Compiler）开始执行字节码：\n●解释器：将字节码逐条解释为机器指令并执行。这种方式的执行速度较慢，但可以快速启动程序。\n●即时编译器（JIT Compiler）：JIT编译器在运行时将热点代码（常用代码）编译成本地机器码，这样代码在后续执行时不需要再解释，执行速度更快。JIT编译器通过这种方式提高了程序的执行效率。\n5. JVM执行与内存管理 JVM不仅负责字节码的执行，还管理程序运行时的内存分配。JVM将内存分为不同的区域，例如堆（Heap）、栈（Stack）、方法区（Method Area）等：\n●堆（Heap）：用于存储对象实例和数组，JVM的垃圾回收器（Garbage Collector）负责在堆中回收不再使用的对象。\n●栈（Stack）：用于存储方法调用和局部变量，每个线程有自己独立的栈空间。\n●方法区（Method Area）：存储类结构（如元数据、常量池、方法数据）和静态变量。\n6. 程序运行 在JVM解释或编译字节码的过程中，程序开始运行。对于上面的示例程序，main方法会被JVM执行，输出“Hello, World!”。\n7. 程序终止 当main方法执行完毕，并且没有其他非守护线程在运行时，JVM会终止程序的执行并释放资源。\n总结 Java程序的执行过程从编写源代码开始，经过编译生成字节码，然后通过JVM加载和解释（或JIT编译）字节码，最终在目标平台上运行。JVM的跨平台性使得Java程序只需编写一次，就可以在不同的操作系统上运行，这也是Java“Write Once, Run Anywhere”理念的体现。\n9、什么是 Java 内部类？它有什么作用？ Java内部类（Inner Class）是定义在另一个类内部的类。Java支持将类定义在另一个类或方法内部，这样的类被称为内部类。内部类可以帮助我们实现更加模块化和更高内聚性的代码设计，并且可以方便地访问外部类的成员变量和方法。\n1. Java内部类的分类 👉成员内部类（Member Inner Class）：\n●定义在外部类内部，并且不使用static修饰符的类。\n●它可以直接访问外部类的所有成员，包括private成员。\n1 2 3 4 5 6 7 8 9 class OuterClass { private String message = \u0026#34;Hello, World!\u0026#34;; class InnerClass { void display() { System.out.println(message); // 访问外部类的成员变量 } } } 👉静态内部类（Static Nested Class）：\n●使用static修饰的内部类，静态内部类不能访问外部类的实例成员（除非通过外部类的对象）。\n●它可以直接创建实例，而不需要外部类的实例。\n1 2 3 4 5 6 7 class OuterClass { static class StaticInnerClass { void display() { System.out.println(\u0026#34;Inside Static Inner Class\u0026#34;); } } } 👉局部内部类（Local Inner Class）：\n●定义在方法或代码块内部的类，它只能在该方法或代码块内部使用。\n●局部内部类只能访问外部类的成员变量和方法，以及方法的final或effectively final变量。\n1 2 3 4 5 6 7 8 9 10 11 class OuterClass { void outerMethod() { class LocalInnerClass { void display() { System.out.println(\u0026#34;Inside Local Inner Class\u0026#34;); } } LocalInnerClass inner = new LocalInnerClass(); inner.display(); } } 👉匿名内部类（Anonymous Inner Class）：\n●没有名字的内部类，通常用来创建继承自一个类或实现一个接口的对象实例。\n●常用于需要简化代码的地方，如事件处理器或回调函数。\n1 2 3 4 5 6 7 8 9 10 11 class OuterClass { void createThread() { Thread t = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;Inside Anonymous Inner Class\u0026#34;); } }); t.start(); } } 2. 内部类的作用 ●封装性增强：\n○内部类可以很好地封装不希望对外暴露的逻辑，它们的存在仅仅是为了与外部类的紧密联系。\n○可以将与外部类关系紧密的类逻辑放在内部类中，从而实现更高的内聚性。\n●访问外部类成员：\n○内部类可以直接访问外部类的成员变量和方法，即使它们是private的。这使得在实现外部类的功能时，可以更方便地操作其数据。\n●实现特定的接口：\n○匿名内部类和局部内部类非常适合用于实现回调函数、事件处理器或接口的实例化，特别是在GUI编程中。\n●创建更加简洁和模块化的代码：\n○使用内部类可以将逻辑紧密相关的代码放在一起，而不是散布在多个类文件中，从而使代码更简洁和易于维护。\n3. 内部类的使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class OuterClass { private String message = \u0026#34;Hello, World!\u0026#34;; class InnerClass { void display() { System.out.println(message); // 可以访问外部类的成员 } } static class StaticInnerClass { void display() { System.out.println(\u0026#34;Inside Static Inner Class\u0026#34;); } } void outerMethod() { class LocalInnerClass { void display() { System.out.println(\u0026#34;Inside Local Inner Class\u0026#34;); } } LocalInnerClass inner = new LocalInnerClass(); inner.display(); } void createThread() { Thread t = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;Inside Anonymous Inner Class\u0026#34;); } }); t.start(); } } public class Main { public static void main(String[] args) { // 成员内部类 OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); inner.display(); // 静态内部类 OuterClass.StaticInnerClass staticInner = new OuterClass.StaticInnerClass(); staticInner.display(); // 局部内部类和匿名内部类 outer.outerMethod(); outer.createThread(); } } 总结 内部类在Java中是一种强大的工具，提供了增强封装性、逻辑组织性和代码简洁性的方法。通过合理使用内部类，可以在特定场景下更好地组织代码，提高代码的可维护性和可读性。\n10、GC 如何调优？ GC 调优的核心思路就是：尽可能的使对象在年轻代被回收，减少对象进入老年代。\n具体调优还是得看场景根据 GC 日志具体分析，常见的需要关注的指标是 Young GC 和 Full GC 触发频率、原因、晋升的速率 、老年代内存占用量等等。比如发现频繁会产生 Full GC，分析日志之后发现没有内存泄漏，只是 Young GC 之后会有大量的对象进入老年代，然后最终触发 Full GC。所以就能得知是 Survivor 空间设置太小，导致对象过早进入老年代，因此调大 Survivor 。或者是晋升年龄设置的太小，也有可能分析日志之后发现是内存泄漏、或者有第三方类库调用了 System.gc等等。反正具体场景具体分析，核心思想就是尽量在新生代把对象给回收了。\n11、JDK 动态代理与 CGLIB 区别? JDK 动态代理是基于接口的，所以要求代理类一定是有定义接口的。\nCGLIB 基于ASM字节码生成工具，它是通过继承的方式来实现代理类，所以要注意 final 方法。\n12、说一下对注解的理解？ 注解其实就是一个标记，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。\n有了标记之后，我们就可以在解析的时候得到这个标记，然后做一些特别的处理，这就是注解的用处。\n注解生命周期有三大类，分别是：\n●RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件。\n●RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了。\n●RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息。\n13、反射用过吗？ 如果你用过，那就不用我多说啥了，场景说一下，然后等着面试官继续挖。\n如果没用过，那就说生产上没用过，不过私下研究过反射的原理。\n反射其实就是Java提供的能在运行期可以得到对象信息的能力，包括属性、方法、注解等，也可以调用其方法。一般的编码不会用到反射，在框架上用的较多，因为很多场景需要很灵活，所以不确定目标对象的类型，届时只能通过反射动态获取对象信息。\n14、双亲委派知道不？来说说看？ 双亲委派模型（Parent Delegation Model） 是 Java 中类加载机制的重要设计模式。它通过分层次的类加载器结构和委派机制，确保了 Java 类的安全加载，防止核心类库被篡改或替换。\n白话一点：如果一个类加载器需要加载类，那么首先它会把这个类加载请求委派给父类加载器去完成，如果父类还有父类则接着委托，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。\nJava 自身提供了 3 种类加载器：\n●Bootstrap ClassLoader（启动类加载器）：是 JVM 自带的最顶层的类加载器，用于加载核心类库（如 rt.jar），如 java.lang.*、java.util.*等核心类。它是用原生代码实现的，负责加载 JDK 中的核心类。\n●Extension ClassLoader（扩展类加载器）：负责加载扩展类库，通常位于 JAVA_HOME/lib/ext 目录下的类库。它由 Java 实现，通常是 sun.misc.Launcher$ExtClassLoader 的实例。\n●Application ClassLoader（应用程序类加载器）：也称为系统类加载器，负责加载应用程序类路径（CLASSPATH）下的类和库。它也是由 Java 实现的，通常是 sun.misc.Launcher$AppClassLoader 的实例。\n15、JDK 和 JRE 的区别？ JRE(Java Runtime Environment)指的是 Java 运行环境，包含了 JVM 和 Java 类库等。\nJDK(Java Development Kit)可以视为 JRE 的超集，还提供了一些工具比如各种诊断工具：jstack，jmap，jstat等。\n16、Java 按值传递还是按引用传递？ Java 只有按值传递，不论是基本类型还是引用类型。\nJVM 内存有划分为栈（Stack）和堆（Heap），局部变量和方法参数是在栈上分配的，基本类型和引用类型都占 4 个字节，当然 long 和 double 占 8 个字节。而对象所占的空间是在堆（Heap）中开辟的，引用类型的变量存储对象在堆中地址来访问对象，所以传递的时候可以理解为把变量存储的地址给传递过去，因此引用类型也是值传递。\n17、泛型有什么用？泛型擦除是什么？ 作用：\n1.泛型可以把类型当作参数一样传递，使得像一些集合类可以明确存储的对象类型，不用显示地强制转化（在没泛型之前只能是Object，然后强转）。\n2.并且在编译期能识别类型，类型错误则会提醒，增加程序的健壮性和可读性。\n泛型擦除：指参数类型其实在编译之后就被抹去了，也就是生成的 class 文件是没有泛型信息的，所以称之为擦除。【在代码里写死的泛型类型是不会被擦除的！例：private Example\u0026lt;String\u0026gt; example;】\n18、说说强、软、弱、虚引用？ Java 根据其生命周期的长短将引用类型又分为强引用、软引用、弱引用、幻象引用。\n●强引用：就是我们平时 new 一个对象的引用。当 JVM 的内存空间不足时，宁愿抛出 OutOfMemoryError 使得程序异常终止，也不愿意回收具有强引用的存活着的对象。\n●软引用：生命周期比强引用短，当 JVM 认为内存空间不足时，会试图回收软引用指向的对象，也就是说在 JVM 抛出 OutOfMemoryError 之前，会去清理软引用对象，适合用在内存敏感的场景。\n●弱引用：比软引用还短，在 GC 的时候，不管内存空间足不足都会回收这个对象，ThreadLocal中的 key 就用到了弱引用，适合用在内存敏感的场景。\n●虚引用：也称幻象引用，之所以这样叫是因为虚引用的 get 永远都是 null，称为get 了个寂寞，所以叫虚。\n19、Exception 和 Error 的区别知道吗？ Exception ：是程序正常运行过程中可以预料到的意外情况，应该被开发者捕获并且进行相应的处理。\nError ：是指在正常情况下不太可能出现的情况，绝大部分的 Error 都会导致程序处于不正常、不可恢复的状态，也就是挂了。所以不便也不需被开发者捕获，因为这个情况下你捕获了也无济于事。\nException和Error都是继承了Throwable类，在Java代码中只有继承了Throwable类的实例才可以被throw或者被catch。\n20、深拷贝和浅拷贝? 深拷贝：完全拷贝一个对象，包括基本类型和引用类型，堆内的引用对象也会复制一份。\n浅拷贝：仅拷贝基本类型和引用，堆内的引用对象和被拷贝的对象共享。\n所以假如拷贝的对象成员间有一个 list，深拷贝之后堆内有 2 个 list，之间不会影响，而浅拷贝的话堆内还是只有一个 list。因此深拷贝是安全的，浅拷贝的话如果有引用对象则原先和拷贝对象修改引用对象的值会相互影响。\n﻿﻿\n21、说说Java的集合类吧？ 常用的集合有 List、Set、Map 等。\n👉List 常见实现类有 ArrayList 和 LinkedList。\n●ArrayList 基于动态数组实现，支持下标随机访问，对删除不友好。\n●LinkedList 基于双向链表实现，不支持随机访问，只能顺序遍历，但是支持O(1)插入和删除元素。\n👉Set 常见实现类有：HashSet、TreeSet、LinkedHashSet。\n●HashSet 其实就是 HashMap 包了层马甲，支持 O(1)查询，无序。\n●TreeSet 基于红黑树实现，支持范围查询，不过基于红黑树的查找时间复杂度是O(lgn)，有序。\n●LinkedHashSet，比 HashSet 多了个双向链表，通过链表保证有序。\n👉Map 常见实现类有：HashMap、TreeMap、LinkedHashMap\n●HashMap 基于哈希表实现，支持 O(1) 查询，无序。\n●TreeMap 基于红黑树实现，O(lgn)查询，有序。\n●LinkedHashMap 同样也是多了双向链表，支持有序，可以很好的支持 LRU（Least Recently Used 最近最少使用，是一种常见的缓存淘汰算法）的实现。\n22、同步、异步、阻塞、非阻塞 IO 的区别？ 这里用简单直白的语言来总结【同步、异步、阻塞、非阻塞IO】的区别：\n●同步IO：发起IO操作后等待结果，完成后才继续。\n●异步IO：发起IO操作后不等待，继续执行其他任务，完成后得到通知。\n●阻塞IO：数据未准备好时等待，不做其他事情。\n●非阻塞IO：数据未准备好时不等待，立即返回，可做其他事情。\n结合这组概念，你可以有三种组合：同步阻塞（BIO）、同步非阻塞（NIO 通常配合轮询机制）、异步非阻塞（AIO 最常见的高效IO模型）。异步和非阻塞都是为了提高程序的并发性和响应性而设计的。\n23、说说Java 并发工具类-CyclicBarrier？ 从名字分析，这是一个可循环的屏障。\n屏障的意思是：让一组线程都运行到同一个屏障点之后，线程会阻塞等待所有线程都达到这个屏障点，然后所有线程才得以继续执行。\n**原理：**首先设置了达到屏障的线程数量，当线程调用 await 的时候计数器会减一，如果计数器减一不等于 0 的时候，线程会调用 condition.await 进行阻塞等待。如果计数器减一的值等于0，说明最后一个线程也到达了屏障，于是如果有 barrierCommand 就执行 barrierCommand，然后调用 condition.signalAll 唤醒之前等待的线程，并且重置计数器（便于循环使用），然后开启下一代。\n﻿﻿\n24、Synchronized 和 ReentrantLock 区别？ ●Synchronized 和 ReentrantLock 都是可重入锁，ReentrantLock 需要手动解锁，而 Synchronized 不需要。\n●ReentrantLock 支持设置超时时间，可以避免死锁，比较灵活，并且支持公平锁，可中断，支持条件判断。\n●Synchronized 不支持超时，非公平，不可中断，不支持条件。\n总的而言，一般情况下用 Synchronized 足矣，比较简单，而 ReentrantLock 比较灵活，支持的功能比较多，所以复杂的情况用 ReentrantLock 。\n25、说说线程的生命周期？ 线程的生命周期可以精简为五个主要状态：\n1.新建（New）：线程对象被创建但还未启动，start()方法尚未调用。\n2.可运行（Runnable）：已调用start()方法，线程可以执行，正在或等待CPU时间片。\n3.阻塞（Blocked）：线程试图获取同步锁未果，暂时无法继续执行，等待获取锁。\n4.等待（Waiting）/计时等待（Timed Waiting）：线程在等待其他线程执行特定动作（如通过wait()或join()），可能有超时也可能没有。为了简化，可以将这两种状态统称为“等待”状态。\n5.终止（Terminated）：线程执行完毕或者因异常退出，生命周期结束。\n","date":"2025-05-21T15:48:16+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/java%E5%9F%BA%E7%A1%80/","title":"Java基础"},{"content":"AOP 与 Spring 事务 学习笔记 关于 AOP 和 Spring 事务，我理解如下：\n什么是 AOP？ AOP，全称 Aspect - Oriented Programming，中文译为 “面向切面编程”。它是一种编程范式，旨在通过分离横切关注点 (Cross - Cutting Concerns) 来提高软件系统的模块化程度。\n想象一下，在我们的应用程序中，有很多功能模块（比如用户管理、订单管理、商品管理等）。除了这些核心业务逻辑之外，还存在一些通用的、分散在各个模块中的功能，例如：\n日志记录 (Logging)：记录方法的调用、参数、返回值等。 权限校验 (Authorization)：检查用户是否有权限执行某个操作。 性能监控 (Performance Monitoring)：记录方法的执行时间。 事务管理 (Transaction Management)：确保一组数据库操作要么全部成功，要么全部失败。 这些功能就像 “切面” 一样，横向地 “切割” 了我们纵向的业务模块。如果我们在每个业务模块中都重复编写这些代码，会导致代码冗余、难以维护。\nAOP 的核心思想就是将这些横切关注点从业务逻辑中剥离出来，形成独立的模块（即 “切面”），然后通过某种方式（通常是动态代理）将这些切面 “织入” 到业务逻辑的特定连接点上。\n核心概念： 切面 (Aspect)：一个模块，它封装了特定的横切关注点。例如，一个日志切面、一个事务切面。 通知 (Advice)：切面在特定连接点上执行的动作。常见的通知类型有： @Before：在目标方法执行之前执行。 @After：在目标方法执行之后执行（无论成功还是失败）。 @AfterReturning：在目标方法成功执行之后执行。 @AfterThrowing：在目标方法抛出异常之后执行。 @Around：环绕目标方法执行，可以控制目标方法的执行。 连接点 (Join Point)：程序执行过程中的某个特定点，例如方法的调用、异常的抛出等。在 Spring AOP 中，连接点通常指方法的执行。 切点 (Pointcut)：一个表达式，用于匹配一个或多个连接点。它定义了通知应该在哪些连接点上执行。 目标对象 (Target Object)：被一个或多个切面所通知的对象。也就是包含主要业务逻辑的类。 织入 (Weaving)：将切面应用到目标对象并创建新的代理对象的过程。织入可以在编译时、加载时或运行时进行。Spring AOP 在运行时进行织入。 代理 (Proxy)：AOP 框架创建的对象，用于封装目标对象并实现切面逻辑。客户端直接与代理对象交互。 AOP 的优势： 降低耦合度：将通用功能与业务逻辑分离，使代码更加清晰和易于维护。 提高代码复用性：可以将通用的横切关注点封装成切面，在多个地方重复使用。 增强模块化：每个模块专注于自身的核心功能。 你们项目中有没有使用到 AOP？ 回答思路： 肯定回答：大概率是有的，因为 Spring 框架本身就大量使用了 AOP。 举例说明：结合项目实际情况，列举 1 - 2 个具体的应用场景，并给出简单的代码示例。 突出作用：说明 AOP 在这些场景中解决了什么问题，带来了什么好处。 回答范例： “是的，面试官，我们项目中广泛地使用了 AOP。\n最典型的应用场景有两个：\n统一日志记录：我们通过 AOP 实现了一个全局的日志切面。这个切面会拦截所有 Service 层方法的调用，在方法执行前后记录方法的入参、出参以及执行耗时。这样做的好处是，我们不需要在每个 Service 方法中手动编写日志记录代码，大大减少了代码冗余，并且使得日志格式和记录时机保持一致，方便后续的问题排查和性能分析。 简单案例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package com.example.aop.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import java.util.Arrays; /** * 日志切面类 */ @Aspect // 声明这是一个切面 @Component // 将这个切面交给Spring容器管理 public class LogAspect { private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); /** * 定义一个切点表达式 * execution(* com.example.aop.service..*.*(..)) * - execution(): 表示执行方法时触发 * - *: 返回任意类型 * - com.example.aop.service..: 表示 com.example.aop.service 包及其所有子包 * - *.: 表示包下的任意类 * - *(..): 表示类中的任意方法名，(..) 表示任意参数 */ @Pointcut(\u0026#34;execution(* com.example.aop.service..*.*(..))\u0026#34;) public void serviceLayerPointcut() { // 这个方法本身只是一个标记，不需要具体实现 // Pointcut 的名称就是方法名 \u0026#34;serviceLayerPointcut\u0026#34; } /** * 前置通知：在目标方法执行之前执行 * @param joinPoint 连接点信息，可以获取方法名、参数等 */ @Before(\u0026#34;serviceLayerPointcut()\u0026#34;) public void logBefore(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); // 获取方法名 Object[] args = joinPoint.getArgs(); // 获取方法参数 logger.info(\u0026#34;===\u0026gt; @Before: Method [{}] execution starts, Args: {}\u0026#34;, methodName, Arrays.toString(args)); } /** * 后置通知：在目标方法执行之后执行（无论成功还是异常都会执行） * @param joinPoint 连接点信息 */ @After(\u0026#34;serviceLayerPointcut()\u0026#34;) public void logAfter(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); logger.info(\u0026#34;===\u0026gt; @After: Method [{}] execution ends.\u0026#34;, methodName); } /** * 返回通知：在目标方法成功执行并返回结果后执行 * @param joinPoint 连接点信息 * @param result 目标方法返回的结果 */ @AfterReturning(pointcut = \u0026#34;serviceLayerPointcut()\u0026#34;, returning = \u0026#34;result\u0026#34;) public void logAfterReturning(JoinPoint joinPoint, Object result) { String methodName = joinPoint.getSignature().getName(); logger.info(\u0026#34;===\u0026gt; @AfterReturning: Method [{}] executed successfully, Result: {}\u0026#34;, methodName, result); } /** * 异常通知：在目标方法抛出异常后执行 * @param joinPoint 连接点信息 * @param exception 抛出的异常对象 */ @AfterThrowing(pointcut = \u0026#34;serviceLayerPointcut()\u0026#34;, throwing = \u0026#34;exception\u0026#34;) public void logAfterThrowing(JoinPoint joinPoint, Throwable exception) { String methodName = joinPoint.getSignature().getName(); logger.error(\u0026#34;===\u0026gt; @AfterThrowing: Method [{}] execution failed, Exception: {}\u0026#34;, methodName, exception.getMessage()); } /** * 环绕通知：可以控制目标方法的执行，功能最强大 * @param proceedingJoinPoint 可执行的连接点，必须调用 proceed() 方法来执行目标方法 * @return 目标方法的返回值 * @throws Throwable 目标方法可能抛出的异常 */ @Around(\u0026#34;serviceLayerPointcut()\u0026#34;) public Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { String methodName = proceedingJoinPoint.getSignature().getName(); Object[] args = proceedingJoinPoint.getArgs(); long startTime = System.currentTimeMillis(); logger.info(\u0026#34;====\u0026gt; @Around: Method [{}] execution starts with Args: {}\u0026#34;, methodName, Arrays.toString(args)); Object result = null; try { // 执行目标方法 result = proceedingJoinPoint.proceed(); long endTime = System.currentTimeMillis(); logger.info(\u0026#34;====\u0026gt; @Around: Method [{}] executed successfully, Result: {}, Execution time: {} ms\u0026#34;, methodName, result, (endTime - startTime)); } catch (Throwable throwable) { long endTime = System.currentTimeMillis(); logger.error(\u0026#34;====\u0026gt; @Around: Method [{}] execution failed, Exception: {}, Execution time: {} ms\u0026#34;, methodName, throwable.getMessage(), (endTime - startTime)); throw throwable; // 必须将异常抛出，否则外部调用者无法感知 } return result; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.example.aop.service; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Service; /** * 示例服务类 */ @Service // 将这个类标记为Spring的Service组件 public class MyService { private static final Logger logger = LoggerFactory.getLogger(MyService.class); public String performAction(String userName, int actionType) { logger.info(\u0026#34;MyService.performAction: Executing business logic for user: {}, action: {}\u0026#34;, userName, actionType); if (actionType \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Action type cannot be negative\u0026#34;); } return \u0026#34;Action performed for \u0026#34; + userName + \u0026#34; with type \u0026#34; + actionType; } public void anotherSimpleMethod() { logger.info(\u0026#34;MyService.anotherSimpleMethod: Executing another simple method.\u0026#34;); } } 要使上述 AOP 生效，还需要在 Spring 配置类中开启 AOP 支持： 1 2 3 4 5 6 7 8 import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; @Configuration @EnableAspectJAutoProxy // 开启AspectJ自动代理支持 public class AppConfig { // 其他配置... } 声明式事务管理：Spring 框架提供的声明式事务管理本身就是基于 AOP 实现的。我们在 Service 层的方法上使用@Transactional注解，Spring 就会自动为这些方法应用事务管理。当方法开始执行时，AOP 会开启事务；当方法执行完毕时，根据执行结果（成功或异常）自动提交或回滚事务。这使得我们的业务代码不再需要关注事务的开启、提交和回滚等细节，更加专注于业务逻辑本身，提高了开发效率和代码的可读性。 概念性代码说明 (非完整运行示例，重点在 AOP 思想)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.example.aop.service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; // 导入注解 // 假设有一个 UserDao 用于数据库操作 // import com.example.aop.dao.UserDao; @Service public class OrderService { // @Autowired // private UserDao userDao; // 假设依赖一个DAO /** * 当调用这个方法时，Spring AOP会创建一个代理。 * 代理会在方法执行前启动事务（类似于 @Before 通知）。 * 如果方法成功完成，代理会在方法执行后提交事务（类似于 @AfterReturning 通知）。 * 如果方法抛出运行时异常（或其他配置的异常），代理会回滚事务（类似于 @AfterThrowing 通知）。 */ @Transactional // 声明此方法需要事务管理 public void createOrder(String product, int quantity) { System.out.println(\u0026#34;OrderService: Attempting to create order for \u0026#34; + product + \u0026#34; with quantity \u0026#34; + quantity); // 1. 假设这里有数据库操作：检查库存 // userDao.checkStock(product, quantity); System.out.println(\u0026#34;OrderService: Stock checked (simulated).\u0026#34;); // 2. 假设这里有数据库操作：创建订单记录 // userDao.createOrderRecord(product, quantity); System.out.println(\u0026#34;OrderService: Order record created (simulated).\u0026#34;); if (quantity \u0026gt; 100) { // 模拟一个业务异常条件 throw new RuntimeException(\u0026#34;Cannot order more than 100 items in a single transaction.\u0026#34;); } // 3. 假设这里有数据库操作：扣减库存 // userDao.decreaseStock(product, quantity); System.out.println(\u0026#34;OrderService: Stock decreased (simulated).\u0026#34;); System.out.println(\u0026#34;OrderService: Order created successfully for \u0026#34; + product); } } 在这个例子中，@Transactional注解就是一个 “切点”，告诉 Spring AOP 在哪里应用事务管理的 “切面”。事务的开启、提交、回滚等逻辑就是 “通知”。 除此之外，我们可能还在权限校验、缓存处理等方面考虑过或使用了 AOP 的思想，将这些非业务核心但又普遍存在的功能进行模块化管理。”\nSpring 中的事务是如何实现的？ Spring 中的事务管理，尤其是声明式事务，是基于 AOP 和 ThreadLocal 实现的。\n核心原理： AOP 代理： 当一个 Bean 被声明为需要事务管理时（例如，通过@Transactional注解），Spring 容器在创建这个 Bean 的时候，并不会直接返回原始的 Bean 实例，而是会为它创建一个代理对象 (Proxy)。 这个代理对象包裹 (wraps) 了原始的 Bean 实例。 当客户端调用 Bean 中被@Transactional注解标记的方法时，实际上是调用了代理对象的相应方法。 事务拦截器 (TransactionInterceptor)： 代理对象的方法内部会包含一个事务拦截器 (例如 TransactionInterceptor)。这个拦截器就是 AOP 中的通知 (Advice)。 在目标业务方法执行之前 (类似@Before通知)，事务拦截器会介入。 它会检查当前是否存在事务，如果不存在，则根据@Transactional注解的配置（如传播行为、隔离级别、只读属性等）开启一个新的数据库事务。 ThreadLocal 存储数据库连接 (Connection)： 为了保证同一个事务中的所有数据库操作都使用同一个数据库连接，Spring 会将当前事务对应的数据库连接 (Connection) 存储在 ThreadLocal 变量中。 ThreadLocal 为每个线程都提供了一个独立的变量副本，这意味着在一个线程的执行过程中，无论调用多少个方法，只要它们在同一个事务内，就能获取到同一个数据库连接。这解决了多线程环境下事务管理的问题，保证了事务的线程安全性。 业务方法执行： 开启事务后，代理对象会调用原始 Bean 实例的业务方法，执行实际的业务逻辑和数据库操作。 由于数据库连接是从ThreadLocal中获取的，所以业务方法中的所有 DAO 操作都会在同一个事务上下文中执行。 事务提交或回滚： 当业务方法执行完毕后，事务拦截器会再次介入 (类似@AfterReturning 或 @AfterThrowing通知)。 如果业务方法正常执行完成，没有抛出任何（未被捕获的、符合回滚规则的）异常，事务拦截器会提交事务。 如果业务方法抛出了异常 (通常是RuntimeException或其子类，或者在@Transactional中配置了rollbackFor指定的异常)，事务拦截器会回滚事务。 关闭连接与清理： 事务提交或回滚之后，事务拦截器会负责关闭数据库连接 (通常是将其归还给连接池)，并清理 ThreadLocal 中存储的连接信息。 总结 Spring 事务实现的关键点： 基于 AOP：通过动态代理和拦截器机制，在业务代码执行前后动态地添加事务管理逻辑。 @Transactional 注解：提供了一种声明式的方式来定义事务的边界和属性，简化了事务管理。 PlatformTransactionManager 接口：Spring 事务管理的核心接口，定义了事务操作（获取事务、提交、回滚）的规范。具体的实现类（如 DataSourceTransactionManager 对应 JDBC，JpaTransactionManager 对应 JPA）负责与底层数据访问技术交互。 TransactionDefinition 接口：定义事务的属性，如传播行为 (Propagation Behavior)、隔离级别 (Isolation Level)、超时时间 (Timeout)、只读状态 (Read - only) 等。@Transactional注解的属性最终会转换为TransactionDefinition的配置。 TransactionStatus 接口：表示当前事务的状态，可以用来控制事务的提交和回滚。 ThreadLocal：确保了在单个线程中，事务操作使用的是同一个数据库连接，从而保证了事务的原子性和一致性。 简单案例思路 (伪代码)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 业务接口 public interface UserService { void A(); void B(); } // 业务实现类 @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; // 假设UserDao用于数据库操作 @Override @Transactional // 声明式事务 public void A() { userDao.updateA(); // 操作1 //... 其他业务逻辑... // int i = 1/0; // 如果这里发生RuntimeException，事务会回滚 userDao.updateB(); // 操作2 } @Override public void B() { // 没有@Transactional，不使用Spring事务管理（除非被A方法调用且传播行为允许） userDao.updateC(); } } Spring AOP 和事务管理大致流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 1. 客户端调用 userService.A() // 2. 实际上调用的是UserService的代理对象 Proxy$UserService.A() Proxy$UserService.A() { TransactionInterceptor interceptor =...; Connection conn = null; TransactionStatus status = null; try { // (Before Advice) 开启事务 status = platformTransactionManager.getTransaction(transactionDefinition); // 获取事务状态，可能开启新事务 conn = dataSource.getConnection(); // 获取连接 conn.setAutoCommit(false); // 关闭自动提交 ThreadLocal\u0026lt;Connection\u0026gt; currentConnection.set(conn); // 将连接绑定到当前线程 // 调用目标方法 targetUserServiceImpl.A(); // 真正执行业务逻辑 // (AfterReturning Advice) 提交事务 platformTransactionManager.commit(status); // 提交 conn.commit(); } catch (RuntimeException e) { // (AfterThrowing Advice) 回滚事务 if (status!= null) { platformTransactionManager.rollback(status); // 回滚 if (conn!= null) conn.rollback(); } throw e; // 抛出异常 } finally { // 清理资源 if (conn!= null) { conn.setAutoCommit(true); // 恢复自动提交（如果需要） conn.close(); // 关闭连接（归还连接池） } ThreadLocal\u0026lt;Connection\u0026gt; currentConnection.remove(); // 清理ThreadLocal } } ","date":"2025-05-21T10:20:40+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spirng%E7%AF%87-aop-%E4%B8%8E-spring-%E4%BA%8B%E5%8A%A1/","title":"Spirng篇-AOP 与 Spring 事务"},{"content":"MySQL 条件表达式学习笔记（CASE \u0026amp; IF） 一、CASE 表达式 1. 基础语法 1 2 3 4 5 6 CASE WHEN condition1 THEN result1 -- 当满足条件1时返回结果1 WHEN condition2 THEN result2 -- 当满足条件2时返回结果2 ... ELSE default_result -- 默认返回值（可选） END 2. 典型应用场景 (1) 状态码转文字描述（数据可视化） 1 2 3 4 5 6 7 8 9 10 SELECT order_id, -- 将数字状态码转换为可读文本 CASE status WHEN 1 THEN \u0026#39;未支付\u0026#39; -- 状态码1对应未支付 WHEN 2 THEN \u0026#39;已支付\u0026#39; -- 状态码2对应已支付 WHEN 3 THEN \u0026#39;已取消\u0026#39; -- 状态码3对应已取消 ELSE \u0026#39;未知状态\u0026#39; -- 兜底处理异常数据 END AS status_text FROM orders; (2) 数据分组统计（报表分析） 1 2 3 4 5 6 7 8 9 10 11 SELECT -- 按年龄区间分组 CASE WHEN age \u0026lt; 18 THEN \u0026#39;未成年\u0026#39; -- 18岁以下分组 WHEN age BETWEEN 18 AND 35 THEN \u0026#39;青年\u0026#39; -- 18-35岁分组 WHEN age \u0026gt; 35 THEN \u0026#39;中年及以上\u0026#39; -- 35岁以上分组 ELSE \u0026#39;未填写年龄\u0026#39; -- 处理NULL值 END AS age_group, COUNT(*) AS user_count -- 统计每组的用户数 FROM users GROUP BY age_group; -- 按分组字段聚合 (3) 多条件商品分类（业务规则实现） 1 2 3 4 5 6 7 8 9 10 11 SELECT product_id, price, -- 根据价格、库存等条件动态分类商品 CASE WHEN price \u0026gt; 1000 THEN \u0026#39;高价商品\u0026#39; -- 单价\u0026gt;1000归为高价 WHEN price \u0026gt; 500 AND stock \u0026lt; 10 THEN \u0026#39;需补货商品\u0026#39; -- 同时满足两个条件 WHEN discount_rate \u0026gt; 0.3 THEN \u0026#39;促销商品\u0026#39; -- 折扣率\u0026gt;30%算促销 ELSE \u0026#39;普通商品\u0026#39; -- 默认分类 END AS product_category FROM products; 二、IF 函数 1. 基础语法 1 2 -- 三目运算符形式：condition ? true_value : false_value IF(condition, true_value, false_value) 2. 典型应用场景 (1) 用户类型标记（二元判断） 1 2 3 4 5 SELECT username, -- 根据is_vip字段返回不同类型文本 IF(is_vip = 1, \u0026#39;VIP用户\u0026#39;, \u0026#39;普通用户\u0026#39;) AS user_type FROM users; (2) 空值处理（数据清洗） 1 2 3 4 5 SELECT order_id, -- 如果address为NULL则显示默认提示 IF(address IS NULL, \u0026#39;未填写地址\u0026#39;, address) AS shipping_address FROM orders; (3) 库存状态预警（业务监控） 1 2 3 4 5 6 7 8 SELECT product_id, -- 库存≤5时标记为紧张状态 IF(stock \u0026lt;= 5, \u0026#39;库存紧张\u0026#39;, \u0026#39;库存充足\u0026#39;) AS stock_status, -- 嵌套IF示例：多级库存预警 IF(stock = 0, \u0026#39;已售罄\u0026#39;, IF(stock \u0026lt;= 3, \u0026#39;紧急补货\u0026#39;, \u0026#39;正常库存\u0026#39;)) AS stock_level FROM products; 三、对比总结表 特性 CASE IF 条件分支 支持多分支（WHEN\u0026hellip;THEN） 仅支持真 / 假两个分支 可读性 复杂逻辑更清晰 简单判断更简洁 返回值类型 所有分支必须类型一致 真假值类型需兼容 典型场景 多状态映射、复杂业务规则 二元判断、NULL 值处理 性能 多分支时解析稍慢 简单判断效率更高 四、高级用法示例 1. 动态更新数据（批量业务处理） 1 2 3 4 5 6 7 8 9 10 UPDATE products SET price = CASE -- 电子产品类打8折 WHEN category_id = 3 THEN price * 0.8 -- 高库存商品打9折 WHEN stock \u0026gt; 100 THEN price * 0.9 -- 其他商品保持原价 ELSE price END WHERE is_on_sale = 1; -- 只处理促销商品 2. 自定义排序（业务优先级） 1 2 3 4 5 6 7 8 9 SELECT * FROM tasks ORDER BY -- 按任务优先级自定义排序权重 CASE priority WHEN \u0026#39;High\u0026#39; THEN 1 -- 高优先级排最前 WHEN \u0026#39;Medium\u0026#39; THEN 2 -- 中优先级 WHEN \u0026#39;Low\u0026#39; THEN 3 -- 低优先级排最后 ELSE 4 -- 无优先级标识的排最后 END ASC; 3. 嵌套混合使用（复杂业务逻辑） 1 2 3 4 5 6 7 8 9 10 11 12 SELECT user_id, -- 先判断是否及格，再细分优良等级 IF(score \u0026gt;= 60, CASE WHEN score \u0026gt;= 90 THEN \u0026#39;优秀\u0026#39; -- ≥90为优秀 WHEN score \u0026gt;= 80 THEN \u0026#39;良好\u0026#39; -- 80-89为良好 ELSE \u0026#39;及格\u0026#39; -- 60-79为及格 END, \u0026#39;不及格\u0026#39; -- \u0026lt;60为不及格 ) AS evaluation FROM exam_results; 五、注意事项 类型安全 1 2 3 4 5 -- 错误示例：混合返回文本和数字 CASE WHEN score \u0026gt; 90 THEN \u0026#39;优秀\u0026#39; WHEN score \u0026gt; 60 THEN 1 -- 会导致类型错误 END NULL 处理 1 2 3 4 5 -- 显式处理NULL情况 CASE WHEN field IS NULL THEN \u0026#39;空值\u0026#39; WHEN field = 0 THEN \u0026#39;零值\u0026#39; END 性能优化 1 2 3 4 5 -- 把高概率条件放在前面 CASE WHEN status = \u0026#39;paid\u0026#39; THEN 1 -- 已支付状态最常见 WHEN status = \u0026#39;unpaid\u0026#39; THEN 2 END 索引失效 1 2 3 -- 避免在WHERE中对索引字段使用函数 SELECT * FROM users WHERE IF(age\u0026gt;18,1,0) = 1 -- 导致age索引失效 六、实战练习 场景：电商订单分析报表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 SELECT order_id, -- 金额分级 CASE WHEN amount \u0026lt; 50 THEN \u0026#39;小额订单(\u0026lt;50)\u0026#39; WHEN amount BETWEEN 50 AND 200 THEN \u0026#39;中额订单(50-200)\u0026#39; ELSE \u0026#39;大额订单(\u0026gt;200)\u0026#39; END AS order_level, -- 支付方式处理 IF(payment_method IN (1,2,3), \u0026#39;在线支付\u0026#39;, \u0026#39;其他支付\u0026#39; ) AS payment_type, -- 物流状态 CASE WHEN shipping_status = 0 THEN \u0026#39;待发货\u0026#39; WHEN shipping_status = 1 AND receive_time IS NULL THEN \u0026#39;运输中\u0026#39; WHEN receive_time IS NOT NULL THEN \u0026#39;已签收\u0026#39; ELSE \u0026#39;状态异常\u0026#39; END AS logistics_status FROM orders WHERE create_time \u0026gt; \u0026#39;2023-01-01\u0026#39;; 通过注释和实际场景示例，可以更清晰地理解 CASE 和 IF 在复杂业务逻辑处理中的应用技巧。建议在数据库管理工具中实际执行这些示例，观察输出结果加深理解。\n","date":"2025-05-20T16:14:34+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/mysql-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0case-if/","title":"MySQL 条件表达式学习笔记（CASE \u0026 IF）"},{"content":"Spring 容器中 单例Bean 的线程安全分析 问题：Spring容器中的单例bean是线程安全的吗？\n结论：不是线程安全的 Spring 容器本身未提供 Bean 的线程安全策略，因此 Spring 容器中的 Bean 默认不具备线程安全特性，具体需结合 Bean 的作用域（Scope）分析。\nSpring Bean 作用域（Scope）类型 singleton：单例（默认作用域） prototype：原型（每次请求创建新实例） request：请求作用域（每次 HTTP 请求创建新实例，适用于 Web 环境） session：会话作用域（同一会话共享实例） global-session：全局会话作用域（所有会话共享实例） 线程安全分析：原型 Bean 与单例 Bean 原型 Bean（prototype） 特性：每次请求创建新实例，线程间无共享 Bean。 结论：天然线程安全，无需额外处理。 单例 Bean（singleton） 特性：所有线程共享同一实例，可能存在资源竞争。 线程安全条件： 无状态 Bean：不存储成员变量状态（如仅包含方法逻辑），线程安全。 有状态 Bean：存储成员变量状态（如成员变量赋值操作），需手动保证线程安全。 为什么 Spring 的 Controller、Service、Dao 默认是线程安全的？ 本质原因：这些组件通常是无状态的，仅包含方法逻辑，不存储线程间共享的状态。 技术支撑： 局部变量存储于线程私有栈（JVM 虚拟机栈），线程间不共享。 方法调用的参数和临时变量均为线程私有，无竞争风险。 参考：《深入理解 JVM 虚拟机》2.2.2 节、《Java 并发编程实战》3.2.2 节。 实战验证：单例 Bean 的线程安全问题 案例 1：单例模式下的有状态 Bean（非线程安全） 1 2 3 4 5 6 7 8 9 10 @RestController public class TestController { private int var = 0; // 成员变量（有状态） @GetMapping(\u0026#34;/test_var\u0026#34;) public String test() { System.out.println(\u0026#34;普通变量var:\u0026#34; + (++var)); return \u0026#34;var: \u0026#34; + var; } } 请求结果：\n1 2 3 普通变量var:1 （第一次请求） 普通变量var:2 （第二次请求） 普通变量var:3 （第三次请求） 结论：成员变量被多线程共享，导致状态不一致，非线程安全。\n案例 2：使用@Scope(\u0026quot;prototype\u0026quot;)的原型 Bean 1 2 3 4 5 6 7 8 9 10 11 @RestController @Scope(\u0026#34;prototype\u0026#34;) // 改为原型作用域 public class TestController { private int var = 0; @GetMapping(\u0026#34;/test_var\u0026#34;) public String test() { System.out.println(\u0026#34;普通变量var:\u0026#34; + (++var)); return \u0026#34;var: \u0026#34; + var; } } 请求结果：\n1 2 3 普通变量var:1 （每次请求均为新实例，结果独立） 普通变量var:1 普通变量var:1 结论：原型 Bean 为每个请求创建独立实例，解决成员变量共享问题。\n特殊场景：静态变量与依赖注入 Bean 的线程安全 场景 1：静态变量（线程不安全） 1 2 3 4 5 6 7 8 9 10 11 @RestController @Scope(\u0026#34;prototype\u0026#34;) public class TestController { private static int staticVar = 0; // 静态变量（类级共享） @GetMapping(\u0026#34;/test_var\u0026#34;) public String test() { System.out.println(\u0026#34;静态变量staticVar:\u0026#34; + (++staticVar)); return \u0026#34;staticVar: \u0026#34; + staticVar; } } 请求结果：\n1 2 3 静态变量staticVar:1 （累加，与作用域无关） 静态变量staticVar:2 静态变量staticVar:3 结论：静态变量属于类级资源，无论作用域如何，均为全局共享，线程不安全。\n场景 2：依赖注入的单例 Bean（线程不安全） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController public class TestController { @Autowired private User user; // 注入单例User Bean @GetMapping(\u0026#34;/test_user\u0026#34;) public String test() { user.setAge(user.getAge() + 1); return \u0026#34;User age: \u0026#34; + user.getAge(); } } @Configuration public class MyConfig { @Bean public User user() { // 默认为单例 return new User(); } } 请求结果：\n1 2 User age: 1 （第一次请求） User age: 2 （第二次请求） 结论：依赖注入的单例 Bean 被多线程共享，需配合@Scope(\u0026quot;prototype\u0026quot;)或线程安全设计。\n线程安全解决方案总结 优先使用无状态设计：避免在 Bean 中定义成员变量，仅通过方法参数或局部变量处理逻辑。 原型作用域（prototype）：对有状态 Bean，使用@Scope(\u0026quot;prototype\u0026quot;)为每个请求创建独立实例。 ThreadLocal：封装需要线程隔离的变量，确保线程私有。 静态变量慎用：静态变量为类级共享，需全局同步控制（不推荐）。 依赖注入 Bean 的作用域匹配：确保注入的 Bean 与当前 Bean 作用域一致（如原型 Bean 注入原型 Bean）。 1 2 3 4 5 6 7 8 9 10 11 // 推荐：使用ThreadLocal实现线程隔离 @RestController public class TestController { private ThreadLocal\u0026lt;Integer\u0026gt; tl = new ThreadLocal\u0026lt;\u0026gt;(); @GetMapping(\u0026#34;/test_tl\u0026#34;) public String test() { tl.set(tl.get() != null ? tl.get() + 1 : 1); return \u0026#34;ThreadLocal value: \u0026#34; + tl.get(); } } 总结 默认单例 Bean 非线程安全：Spring 默认使用单例模式，无状态 Bean 可视为线程安全，有状态 Bean 需额外处理。 作用域选择： 无状态 Bean：使用单例（性能最优）。 有状态 Bean：使用原型或结合 ThreadLocal。 核心原则：减少共享状态，优先通过设计规避线程安全问题，而非依赖框架兜底。 ","date":"2025-05-19T22:44:14+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spring%E7%AF%87-spring-%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8D%95%E4%BE%8Bbean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/","title":"Spring篇-Spring 容器中单例Bean的线程安全分析"},{"content":"Java 中 Bean、单例及单例 Bean 的学习笔记 一、Bean （一）概念 在 Java 开发，尤其是 Spring 框架中，Bean 是被 Spring 容器实例化、配置与管理的对象。Spring 容器掌控 Bean 的创建、生命周期管理以及依赖关系处理。\n（二）示例 - 图书管理系统中的 BookService BookService 类定义 1 2 3 4 5 6 7 8 9 public class BookService { public void addBook(String title, String author) { System.out.println(\u0026#34;Adding book: \u0026#34; + title + \u0026#34; by \u0026#34; + author); } public void findBook(String title) { System.out.println(\u0026#34;Finding book: \u0026#34; + title); } } 此 BookService 类负责处理图书相关业务逻辑，如添加和查询图书。\n使用 Spring 注解配置为 Bean 1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.stereotype.Service; @Service public class BookService { public void addBook(String title, String author) { System.out.println(\u0026#34;Adding book: \u0026#34; + title + \u0026#34; by \u0026#34; + author); } public void findBook(String title) { System.out.println(\u0026#34;Finding book: \u0026#34; + title); } } 通过 @Service 注解，将 BookService 声明为 Spring 中的一个 Bean。\n在 BookController 中依赖注入使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class BookController { private final BookService bookService; @Autowired public BookController(BookService bookService) { this.bookService = bookService; } @GetMapping(\u0026#34;/addBook\u0026#34;) public String addBook(@RequestParam String title, @RequestParam String author) { bookService.addBook(title, author); return \u0026#34;Book added successfully\u0026#34;; } } BookController 通过依赖注入获取 BookService 的实例，进而调用其方法处理业务。\n二、单例模式 （一）概念 单例是一种设计模式，确保一个类在整个应用程序中仅有一个实例，并提供全局访问点获取该实例。\n（二）示例 - 日志记录器 饿汉式单例模式实现日志记录器 1 2 3 4 5 6 7 8 9 10 11 12 public class LoggerSingleton { private static final LoggerSingleton INSTANCE = new LoggerSingleton(); private LoggerSingleton() {} public void logMessage(String message) { System.out.println(\u0026#34;Logging: \u0026#34; + message); } public static LoggerSingleton getInstance() { return INSTANCE; } } 类加载时就创建 INSTANCE 实例，构造函数私有防止外部实例化，通过 getInstance 方法获取唯一实例。\n使用示例 1 2 3 4 5 6 7 8 9 public class MainApp { public static void main(String[] args) { LoggerSingleton logger1 = LoggerSingleton.getInstance(); LoggerSingleton logger2 = LoggerSingleton.getInstance(); logger1.logMessage(\u0026#34;First log message\u0026#34;); logger2.logMessage(\u0026#34;Second log message\u0026#34;); System.out.println(logger1 == logger2); // 输出 true，表明是同一个实例 } } 多次获取的 LoggerSingleton 实例是同一个，保证日志记录的一致性并避免资源浪费。\n三、单例 Bean （一）概念 在 Spring 框架中，默认情况下，Spring 容器创建的 Bean 是单例 Bean，即在整个 Spring 应用上下文中，特定 Bean 定义仅有一个实例。\n（二）示例 - BookService 作为单例 Bean UserService 和 OrderService 依赖 BookService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class UserService { private final BookService bookService; @Autowired public UserService(BookService bookService) { this.bookService = bookService; } public void userRelatedBookOperation() { bookService.addBook(\u0026#34;User - Book 1\u0026#34;, \u0026#34;User - Author 1\u0026#34;); } } @Service public class OrderService { private final BookService bookService; @Autowired public OrderService(BookService bookService) { this.bookService = bookService; } public void orderRelatedBookOperation() { bookService.findBook(\u0026#34;Order - Book 1\u0026#34;); } } UserService 和 OrderService 都依赖 BookService，且注入的是同一个 BookService 实例。\n共享状态特性\n若 UserService 修改了 BookService 的内部状态，OrderService 获取到的 BookService 也会体现该修改，因为它们共享同一实例。这展示了 Spring 中单例 Bean 的特性，有助于减少内存开销并方便组件间共享状态与行为。 ","date":"2025-05-19T11:35:51+08:00","image":"https://wp-cdn.4ce.cn/v2/hjEyjjL.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/java-%E4%B8%AD-bean%E5%8D%95%E4%BE%8B%E5%8F%8A%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Java 中 Bean、单例及单例 Bean 的学习笔记"},{"content":"如何实现简单的员工删除功能 内容概览：\n删除员工功能 - 支持批量删除 修改员工功能 - 查询回显 + 数据更新 异常处理机制 - 全局异常处理器 员工信息统计 - 职位统计 + 性别统计 1. 批量删除员工功能 1.1 需求分析 支持单个 / 批量删除员工（通过 ID 列表操作） 需同时删除员工基本信息（emp表）和相关工作经历（emp_expr表） 业务规则：确保主从表数据一致性，通过事务保证原子性 1.2 核心代码实现 Controller 层 方法一：用数组 1 2 3 4 5 6 7 8 9 10 @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @DeleteMapping public Result delete(Integer[] ids){ log.info(\u0026#34;员工删除: {}\u0026#34;,Arrays.toString(ids)); //调用service层代码略 return Result.success(); } } 方法二：用List集合(建议) 1 2 3 4 5 6 7 8 9 10 @RestController @RequestMapping(\u0026#34;/emps\u0026#34;) public class EmpController { @DeleteMapping public Result delete(@RequestParam(\u0026#34;ids\u0026#34;) List\u0026lt;Integer\u0026gt; ids) { log.info(\u0026#34;执行批量删除：ids={}\u0026#34;, ids); empService.deleteByIds(ids); return Result.success(); } } Service 层（事务控制） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Autowired private EmpExprMapper empExprMapper; @Override @Transactional // 声明式事务管理 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids) { // 1. 删除员工基本信息 empMapper.deleteByIds(ids); // 2. 删除关联的工作经历 empExprMapper.deleteByEmpIds(ids); } } Mapper 层（MyBatis 动态 SQL） xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!-- empMapper.xml --\u0026gt; \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; DELETE FROM emp WHERE id IN \u0026lt;!-- 遍历ids集合，生成IN条件 --\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; #{id} \u0026lt;!-- 插入当前id值 --\u0026gt; \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;!-- empExprMapper.xml --\u0026gt; \u0026lt;delete id=\u0026#34;deleteByEmpIds\u0026#34;\u0026gt; DELETE FROM emp_expr WHERE emp_id IN \u0026lt;foreach collection=\u0026#34;empIds\u0026#34; item=\u0026#34;empId\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;!-- 遍历empIds集合，生成IN条件 --\u0026gt; #{empId} \u0026lt;!-- 插入当前empId值 --\u0026gt; \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 2. 修改员工功能 2.1 查询回显实现（复杂结果集映射） 数据库表关联查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;resultMap id=\u0026#34;empWithExprResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;!-- 主表字段映射 --\u0026gt; \u0026lt;id column=\u0026#34;emp_id\u0026#34; property=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;username\u0026#34; property=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;!-- 一对多关联：工作经历列表 --\u0026gt; \u0026lt;collection property=\u0026#34;exprList\u0026#34; ofType=\u0026#34;EmpExpr\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;expr_id\u0026#34; property=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;company\u0026#34; property=\u0026#34;company\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;start_time\u0026#34; property=\u0026#34;startTime\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;end_time\u0026#34; property=\u0026#34;endTime\u0026#34; /\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026#34;getEmpById\u0026#34; resultMap=\u0026#34;empWithExprResultMap\u0026#34;\u0026gt; SELECT e.id AS emp_id, e.username, e.name, ee.id AS expr_id, ee.company, ee.start_time, ee.end_time FROM emp e LEFT JOIN emp_expr ee ON e.id = ee.emp_id WHERE e.id = #{id} \u0026lt;/select\u0026gt; 2.2 更新员工实现（动态 SQL + 事务） 主表动态更新 xml\n1 2 3 4 5 6 7 8 9 10 \u0026lt;update id=\u0026#34;updateEmp\u0026#34;\u0026gt; UPDATE emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; update_time = NOW() \u0026lt;/set\u0026gt; WHERE id = #{id} \u0026lt;/update\u0026gt; Service 层事务逻辑 java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Override @Transactional public void updateEmp(Emp emp) { // 1. 更新基本信息 empMapper.updateEmp(emp); // 2. 先删除旧工作经历 empExprMapper.deleteByEmpId(emp.getId()); // 3. 新增新工作经历（如果有） if (!CollectionUtils.isEmpty(emp.getExprList())) { emp.getExprList().forEach(expr -\u0026gt; expr.setEmpId(emp.getId())); empExprMapper.insertBatch(emp.getExprList()); } } 3. 全局异常处理机制 3.1 统一异常处理器 java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @RestControllerAdvice public class GlobalExceptionHandler { // 处理所有未捕获异常 @ExceptionHandler(Exception.class) public Result\u0026lt;String\u0026gt; handleGlobalException(Exception ex) { log.error(\u0026#34;全局异常：{}\u0026#34;, ex.getMessage(), ex); return Result.error(\u0026#34;服务器内部错误，请联系管理员\u0026#34;); } // 处理数据库唯一约束异常（如手机号重复） @ExceptionHandler(SQLIntegrityConstraintViolationException.class) public Result\u0026lt;String\u0026gt; handleDuplicateException(SQLIntegrityConstraintViolationException ex) { if (ex.getMessage().contains(\u0026#34;Duplicate entry\u0026#34;)) { return Result.error(\u0026#34;数据已存在，请勿重复提交\u0026#34;); } return Result.error(\u0026#34;数据库操作失败\u0026#34;); } // 处理业务校验异常 @ExceptionHandler(BusinessException.class) public Result\u0026lt;String\u0026gt; handleBusinessException(BusinessException ex) { return Result.error(ex.getMessage()); } } 4. 员工信息统计功能 4.1 职位统计（SQL 分组 + 数据转换） Mapper 层统计 SQL xml\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;countJobStatistics\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; SELECT CASE job WHEN 1 THEN \u0026#39;班主任\u0026#39; WHEN 2 THEN \u0026#39;讲师\u0026#39; ELSE \u0026#39;其他职位\u0026#39; END AS position, COUNT(*) AS count FROM emp GROUP BY job ORDER BY count DESC \u0026lt;/select\u0026gt; Service 层数据封装 java\n1 2 3 4 5 6 7 8 9 10 public Map\u0026lt;String, Object\u0026gt; getJobStatistics() { List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list = empMapper.countJobStatistics(); List\u0026lt;String\u0026gt; positions = list.stream().map(m -\u0026gt; (String) m.get(\u0026#34;position\u0026#34;)).collect(Collectors.toList()); List\u0026lt;Integer\u0026gt; counts = list.stream().map(m -\u0026gt; (Integer) m.get(\u0026#34;count\u0026#34;)).collect(Collectors.toList()); return new HashMap\u0026lt;\u0026gt;() {{ put(\u0026#34;labels\u0026#34;, positions); put(\u0026#34;data\u0026#34;, counts); }}; } 4.2 性别统计（使用 IF 函数分组） Mapper 层统计 SQL xml\n1 2 3 4 5 6 7 \u0026lt;select id=\u0026#34;countGenderStatistics\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; SELECT IF(gender = 1, \u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;) AS gender, COUNT(*) AS count FROM emp GROUP BY gender \u0026lt;/select\u0026gt; 返回结果示例 json\n1 2 3 4 { \u0026#34;gender\u0026#34;: [\u0026#34;男\u0026#34;, \u0026#34;女\u0026#34;], \u0026#34;count\u0026#34;: [15, 8] } 🎯 关键知识点总结 1. 批量操作处理 MyBatis 技巧：使用\u0026lt;foreach\u0026gt;标签实现 IN 条件，collection属性支持List/Array 参数传递：Controller 层需用@RequestParam(\u0026quot;ids\u0026quot;)接收数组参数 2. 复杂结果映射 一对多关联：通过\u0026lt;collection\u0026gt;标签映射主从表关系，需使用别名避免字段冲突 性能优化：使用LEFT JOIN保留主表数据，即使从表无记录也能正常回显 3. 事务管理要点 注解范围：@Transactional应添加在 Service 层方法上，而非 Mapper 层 操作顺序：更新关联数据时建议先删除旧数据再插入新数据，避免唯一键冲突 4. 异常处理最佳实践 分层处理：区分业务异常（BusinessException）和技术异常（数据库异常） 友好提示：对唯一性约束异常等特定场景返回明确错误信息，避免暴露数据库细节 5. 统计查询技巧 数据转换：使用CASE WHEN或IF函数将数据库枚举值转换为前端展示文本 结果适配：将统计结果封装为{labels, data}格式，直接对接 ECharts 等图表组件 🚦 联调测试要点 1. 批量删除测试 单条测试：传入单个 ID，验证emp和emp_expr表对应记录是否删除 批量测试：传入多个 ID（如 [1,3,5]），检查事务是否保证全部成功或回滚 边界测试：传入空列表、重复 ID，验证接口是否抛出合理异常 2. 修改功能测试 基本信息更新：修改姓名、手机号等字段，验证数据库是否正确更新 工作经历变更：新增 / 删除工作经历条目，确保旧数据清除且新数据正确插入 唯一约束测试：尝试修改手机号为已存在的值，验证是否触发唯一性异常 3. 统计功能验证 数据分组：检查不同职位 / 性别的统计结果是否与实际数据一致 特殊值处理：测试gender为NULL的记录是否被正确归类（可自定义默认值） 格式校验：确认返回数据结构符合前端图表组件的要求（如数组顺序、字段名） 📚 扩展建议 权限控制：为删除 / 修改功能添加角色校验（如仅管理员可操作） 日志审计：记录员工操作日志（操作人、时间、数据前后对比） 性能优化：对高频查询添加缓存（如使用 Redis 存储统计结果） 分页支持：在统计接口中添加分页参数，避免大数据量下性能问题 通过本指南，可完整实现企业级员工管理系统的核心功能，覆盖 CRUD、事务控制、异常处理及数据统计等关键场景，满足中大型应用的业务需求。\n","date":"2025-05-18T15:08:07+08:00","image":"https://wp-cdn.4ce.cn/v2/r6A3HJ2.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%91%98%E5%B7%A5%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/","title":"如何实现简单的员工删除功能"},{"content":"使用阿里云 OSS 对象存储服务学习笔记 🔧 1. 准备工作 1.1 账号准备 注册阿里云账户\n🔗 访问阿里云注册页面完成注册\n✅ 注册后需完成实名认证 登录阿里云控制台\n👨‍💻 使用注册账号登录控制台 1.2 开通 OSS 云服务 在控制台中搜索并找到 对象存储 OSS 服务 首次访问需点击 “开通服务” 完成开通 进入对象存储控制台 创建 Bucket：\n🗂️ 点击左侧 “Bucket 列表”→“创建 Bucket”→ 配置地域、权限等基本信息 1.3 配置 AccessKey 1 2 3 4 5 6 7 8 9 10 11 # 临时环境变量（仅当前终端生效） set OSS_ACCESS_KEY_ID=your_access_key_id set OSS_ACCESS_KEY_SECRET=your_access_key_secret # 永久生效（需重启终端或系统） setx OSS_ACCESS_KEY_ID \u0026#34;%OSS_ACCESS_KEY_ID%\u0026#34; setx OSS_ACCESS_KEY_SECRET \u0026#34;%OSS_ACCESS_KEY_SECRET%\u0026#34; # 验证配置是否生效 echo %OSS_ACCESS_KEY_ID% echo %OSS_ACCESS_KEY_SECRET% 🚀 2. 快速入门 2.1 添加依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- 核心依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun.oss\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-sdk-oss\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.17.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 辅助依赖（JAXB相关，用于XML解析） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.xml.bind\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.activation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;activation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.glassfish.jaxb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jaxb-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.2 基础示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import java.io.FileInputStream; public class OSSDemo { public static void main(String[] args) { // 关键配置：Endpoint、Bucket名称、对象键（文件名） String endpoint = \u0026#34;https://oss-cn-beijing.aliyuncs.com\u0026#34;; String bucketName = \u0026#34;your-bucket-name\u0026#34;; String objectName = \u0026#34;demo.jpg\u0026#34;; // 创建OSS客户端（从环境变量读取AccessKey） OSS ossClient = new OSSClientBuilder() .build(endpoint, new EnvironmentVariableCredentialsProvider()); try { // 上传本地文件（需提前准备local.jpg） ossClient.putObject(bucketName, objectName, new FileInputStream(\u0026#34;local.jpg\u0026#34;)); System.out.println(\u0026#34;文件上传成功！\u0026#34;); } finally { // 关闭客户端连接 if (ossClient != null) { ossClient.shutdown(); } } } } 🧩 3. 项目集成方案 3.1 REST 接口设计 要素 说明 请求路径 /upload 请求方式 POST 参数格式 multipart/form-data（文件字段名：file） 成功响应 ```json { \u0026ldquo;code\u0026rdquo;: 1, \u0026ldquo;msg\u0026rdquo;: \u0026ldquo;success\u0026rdquo;, \u0026ldquo;data\u0026rdquo;: \u0026ldquo;https://your-bucket.oss-cn-beijing.aliyuncs.com/demo.jpg\u0026rdquo; } 3.2 核心组件实现 配置属性类（统一管理OSS参数） 1 2 3 4 5 6 7 8 9 10 11 12 import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliyunOSSProperties { private String endpoint; // OSS访问域名（如：https://oss-cn-beijing.aliyuncs.com） private String bucketName; // Bucket名称 private String region; // 地域（如：cn-beijing） } 上传工具类（封装核心操作） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.aliyun.oss.OSS; import java.io.ByteArrayInputStream; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.util.UUID; @Component public class OSSUploadUtils { @Autowired private OSS ossClient; @Autowired private AliyunOSSProperties ossConfig; public String upload(byte[] fileBytes, String originalFilename) { // 生成唯一文件路径（按年月分目录 + UUID命名） String fileDir = LocalDate.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy/MM\u0026#34;)); String fileSuffix = getFileExtension(originalFilename); String filePath = fileDir + \u0026#34;/\u0026#34; + UUID.randomUUID() + fileSuffix; // 执行上传 ossClient.putObject(ossConfig.getBucketName(), filePath, new ByteArrayInputStream(fileBytes)); // 生成访问URL return String.format(\u0026#34;%s/%s/%s\u0026#34;, ossConfig.getEndpoint().replace(\u0026#34;https://\u0026#34;, \u0026#34;\u0026#34;), ossConfig.getBucketName(), filePath); } private String getFileExtension(String filename) { return filename.substring(filename.lastIndexOf(\u0026#34;.\u0026#34;)); } } 控制器实现（处理文件上传请求） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; @RestController public class FileUploadController { @Autowired private OSSUploadUtils ossUploadUtils; @PostMapping(\u0026#34;/upload\u0026#34;) public Result\u0026lt;String\u0026gt; handleUpload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { if (file.isEmpty()) { return Result.error(\u0026#34;文件不能为空\u0026#34;); } try { String url = ossUploadUtils.upload( file.getBytes(), file.getOriginalFilename() ); return Result.success(url); } catch (Exception e) { return Result.error(\u0026#34;文件上传失败：\u0026#34; + e.getMessage()); } } } // 通用返回结果类 class Result\u0026lt;T\u0026gt; { private int code; private String msg; private T data; // 省略构造方法、Getter/Setter } 🎯 4. 优化策略 配置管理方案对比 方案 优点 缺点 @Value 注解 简单直接，适合少量配置 配置分散在代码中，维护成本高 @ConfigurationProperties 集中管理在 YAML 文件，类型安全 需要创建独立配置类 推荐配置方式（YAML 集中管理） 1 2 3 4 5 6 # application.yml aliyun: oss: endpoint: https://oss-cn-beijing.aliyuncs.com # OSS域名 bucketName: production-bucket # 生产环境Bucket region: cn-beijing # 地域 1 2 3 // 自动注入配置类 @Autowired private AliyunOSSProperties ossConfig; 📝 5. 最佳实践总结 环境隔离\n🔄 为开发（dev）、测试（test）、生产（prod）环境分别创建独立 Bucket，避免资源混用\n安全策略\n🔒 使用 RAM 子账号替代主账号 AccessKey，并通过 RAM 策略限制子账号仅能操作指定 Bucket\n性能优化\n⚡ 大文件（\u0026gt;100MB）使用分片上传（Upload Part），小文件使用直传（Put Object）\n监控告警\n📊 在阿里云监控中配置 OSS 请求失败率、流量峰值等告警规则\n成本控制\n💰 通过 Bucket 生命周期规则自动清理过期文件（如：保留 30 天日志文件）\n💡 提示：本方案经实际验证支持百万级文件并发上传，建议在企业级应用中结合 CDN 加速静态资源访问\n","date":"2025-05-18T14:48:23+08:00","image":"https://wp-cdn.4ce.cn/v2/nid0TSK.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91-oss-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/","title":"如何使用阿里云 OSS 对象存储服务"},{"content":"简单的文件上传功能的实现 1. 概述 文件上传功能允许用户将本地文件（如图片、视频、音频）传输到服务器，常见于微博、微信朋友圈等场景。实现需结合前端表单和后端接口处理。\n2. 实现步骤 2.1 前端表单 使用\u0026lt;form\u0026gt;标签提交数据，要注意的三要素：\nenctype=\u0026quot;multipart/form-data\u0026quot;以支持文件传输。 method类型必须为POST。 需要有一个\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot;\u0026gt;，才能上传文件。 1 2 3 4 5 6 \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 姓名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 年龄：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 图像：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传文件\u0026#34; name=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 2.2 后端控制器（Spring Boot） 通过@PostMapping接收文件，使用MultipartFile处理上传内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 定义一个REST风格的控制器类，用于处理文件上传请求 @RestController public class UploadController { // 处理POST请求，路径为\u0026#34;/upload\u0026#34; @PostMapping(\u0026#34;/upload\u0026#34;) // 方法参数：name（字符串类型），age（整数类型），file（MultipartFile类型） public Result upload(String name, Integer age, MultipartFile file) throws IOException { // 打印日志，记录上传的文件信息 log.info(\u0026#34;文件上传: {}, {}, {}\u0026#34;, name, age, file); // 保存文件到指定目录 // 获取上传文件的原始文件名 String originalFilename = file.getOriginalFilename(); // 生成新的文件名： // 1. 获取文件扩展名（从最后一个\u0026#34;.\u0026#34;开始截取） String extension = originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); // 2. 使用UUID生成随机文件名，并拼接扩展名 String newFileName = UUID.randomUUID().toString() + extension; // 将文件保存到本地目录（这里是Windows桌面下的images文件夹） file.transferTo(new File(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\杂项\\\\images\\\\\u0026#34; + newFileName)); // 返回成功结果 return Result.success(); } } 这段代码实现了一个基于Spring Boot的文件上传功能，下面我将讲解其中的关键知识点：\n@RestController 注解 这是一个组合注解，相当于@Controller + @ResponseBody 表示这个类是一个RESTful风格的控制器，所有方法的返回值都会自动转换为JSON格式 @PostMapping 注解 用于映射HTTP POST请求到特定的处理方法 这里指定了路径为\u0026quot;/upload\u0026quot;，表示处理上传到该路径的POST请求 文件上传参数 MultipartFile是Spring提供的接口，用于处理文件上传 可以获取文件名(getOriginalFilename())、文件内容、大小等信息 文件上传时，表单的enctype必须设置为multipart/form-data 文件处理流程 ​​获取原始文件名​​：file.getOriginalFilename() ​​提取文件扩展名​​：通过lastIndexOf(\u0026quot;.\u0026quot;)找到最后一个点，然后截取后缀 ​​生成新文件名​​：使用UUID.randomUUID()生成唯一ID，避免文件名冲突 ​​保存文件​​：transferTo()方法将文件保存到指定路径 文件存储路径 代码中使用的是绝对路径C:\\Users\\LENOVO\\Desktop\\杂项\\images\\ 3. 核心知识点 3.1 文件存储方法 获取文件名：multipartFile.getOriginalFilename() 保存到本地：multipartFile.transferTo(File dest) 3.2 文件大小限制配置 默认限制为 1MB，超出需在配置文件中调整：\n1 2 3 4 5 spring: servlet: multipart: max-file-size: 10MB # 单个文件最大大小 max-request-size: 100MB # 请求总大小（含所有文件） 4. 注意事项 文件大小限制\n默认配置可能导致大文件上传失败，需根据需求调整application.yml。\n安全性\n校验文件类型，防止恶意文件上传（如.exe）。 限制上传目录权限，避免非法访问。 异常处理\n捕获IOException或SizeLimitExceededException，返回友好提示。\n文件名冲突\n建议对上传文件重命名（如UUID），避免覆盖已有文件。\n5. 总结 前端表单需设置enctype=\u0026quot;multipart/form-data\u0026quot;。 后端通过MultipartFile接收文件，使用transferTo()保存。 配置文件大小限制，增强安全防护。 ","date":"2025-05-17T21:33:41+08:00","image":"https://wp-cdn.4ce.cn/v2/ClJAL1y.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/","title":"如何实现简单的文件上传功能"},{"content":"事务管理 一、什么是事务 在计算机系统中，特别是数据库系统中，事务是一系列严谨执行的逻辑操作单元。这些操作要么全部成功执行，要么全部不执行。它是一个不可分割的工作单位，即使这系列操作由多个独立的步骤组成，从外部看来，这一系列操作也如同一个单一的操作。\n举个生活中的例子：\n银行转账是一个典型的事务。假设A要转100元给B：\n从A账户扣除100元。 向B账户增加100元。 这两个操作必须要么都成功，要么都失败。\n都成功： A账户减少100元，B账户增加100元，转账完成。 都失败： 如果在扣除A账户的钱后，系统崩溃导致无法给B账户增加钱，那么A账户扣除的100元必须回滚（退回到A账户），确保账户总金额不变，转账失败。 绝不能出现A账户扣了钱，B账户没收到钱，或者A账户没扣钱，B账户却收到了钱的情况。\n二、为什么需要事务管理 事务管理的主要目的是为了确保数据的一致性 (Consistency) 和 完整性 (Integrity)，尤其是在并发环境（多个用户或程序同时访问和修改数据）和可能发生系统故障的情况下。\n数据一致性： 保证数据从一个一致的状态转变到另一个一致的状态。例如，在转账操作中，无论成功与否，银行系统的总资金应该保持不变。 并发控制： 当多个事务同时操作同一份数据时，事务管理可以防止数据混乱和错误，例如“脏读”、“不可重复读”、“幻读”等问题。 故障恢复： 当系统发生断电、崩溃等意外情况时，事务管理能够确保未完成的事务对数据的修改被撤销，已完成的事务对数据的修改被持久化，从而将数据恢复到一个一致的状态。 三、事务的四大特征/ACID特性 事务具有四个经典的特性，通常被称为 ACID 特性，这是衡量一个事务管理系统是否可靠的重要标准：\n原子性 (Atomicity):\n含义： 事务是一个不可分割的最小工作单元。事务中的所有操作要么全部提交成功，要么全部失败回滚。如果任何一个操作失败，整个事务都将回滚到最初状态，就像这个事务从未执行过一样。 重要性： 保证了操作的完整性，不会出现部分成功部分失败的中间状态。 一致性 (Consistency):\n含义： 事务执行的结果必须使数据库从一个一致性状态转变到另一个一致性状态。一致性关注的是数据的业务规则和约束不被破坏。 重要性： 维护数据的正确性和业务逻辑的完整性。例如，银行转账后，双方账户的总金额应该保持不变（如果只考虑这两个账户）。数据库的约束（如主键、外键、唯一性约束、检查约束等）也必须得到满足。 隔离性 (Isolation):\n含义： 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。 重要性： 在并发环境下，防止多个事务同时操作数据时可能引发的问题，如脏读、不可重复读、幻读。数据库系统通过不同的隔离级别来实现不同程度的隔离性。 持久性 (Durability):\n含义： 一旦事务成功提交，则其对数据库数据的修改就是永久性的，即使后续系统发生故障（如断电或系统崩溃）也不会丢失。 重要性： 保证了数据的可靠性。通常通过将事务日志（redo log, undo log）持久化到磁盘来实现。 四、事务的具体操作 事务的具体操作通常涉及到以下几个关键命令或阶段：\n开始事务 (Begin Transaction / Start Transaction):\n描述： 标记一个事务的开始。在此之后的数据库操作都将被视为该事务的一部分。 SQL示例： START TRANSACTION; (以MySQL) 执行事务操作 (Executing Transaction Operations):\n描述： 在事务开始后，执行一系列的数据库操作，如 INSERT, UPDATE, DELETE, SELECT 等。这些操作在此时可能只是记录在事务日志中，或者在内存中进行修改，并不一定立即写入到物理磁盘。 提交事务 (Commit Transaction):\n描述： 如果事务中的所有操作都成功执行，并且业务逻辑允许，则提交事务。提交后，事务所做的所有数据修改将被永久保存到数据库中（满足持久性）。 SQL示例： COMMIT; 回滚事务 (Rollback Transaction):\n描述： 如果在事务执行过程中发生任何错误（如SQL执行失败、业务逻辑校验失败、系统异常等），或者业务需要取消该事务，则回滚事务。回滚会将数据库恢复到该事务开始之前的状态，撤销该事务已经进行的所有修改（满足原子性）。 SQL示例： ROLLBACK; 设置保存点 (Savepoint - 可选):\n描述： 在一个较长的事务中，可以设置一个或多个保存点。如果后续操作出现问题，可以选择回滚到某个指定的保存点，而不是回滚整个事务。这为事务提供了更细粒度的控制。 SQL示例： 设置保存点： SAVEPOINT point_name; 回滚到保存点： ROLLBACK TO SAVEPOINT point_name; 注意： 回滚到保存点后，之前的操作仍然是事务的一部分，可以选择继续执行其他操作后提交整个事务，或者回滚整个事务。 简单流程示例 (SQL):\nSQL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 开始一个新的事务 START TRANSACTION; -- 尝试操作1：从账户X扣款100 UPDATE accounts SET balance = balance - 100 WHERE account_id = \u0026#39;X\u0026#39;; -- 尝试操作2：向账户Y存款100 UPDATE accounts SET balance = balance + 100 WHERE account_id = \u0026#39;Y\u0026#39;; -- 检查是否发生错误或业务逻辑是否满足 -- IF 发生错误 THEN -- ROLLBACK; -- 回滚所有操作 -- ELSE -- COMMIT; -- 提交所有操作，使其永久生效 -- END IF; 五、事务的隔离级别 为了平衡并发性能和数据一致性的需求，数据库系统定义了不同的事务隔离级别。隔离级别越高，数据一致性越好，但并发性能可能会受到影响。常见的隔离级别从低到高包括：\n读未提交 (Read Uncommitted):\n现象： 允许一个事务读取另一个事务尚未提交的修改（脏数据）。 问题： 可能导致脏读 (Dirty Read)。 性能： 并发性能最高，但数据一致性最差。很少在实际应用中使用。 读已提交 (Read Committed):\n现象： 一个事务只能读取到其他事务已经提交的数据。解决了脏读问题。 问题： 在同一个事务内，多次读取同一数据，可能会得到不同的结果，因为其他事务可能在此期间提交了对该数据的修改。这称为不可重复读 (Non-Repeatable Read)。 性能： 大多数数据库的默认隔离级别（如 Oracle, SQL Server, PostgreSQL）。 可重复读 (Repeatable Read):\n现象： 保证在一个事务中多次读取同一数据时，结果始终一致。解决了不可重复读的问题。 问题： 在一个事务中，当多次按照某个范围条件读取数据时，可能会发现其他事务在此期间插入了新的、符合该范围条件的数据，导致后续读取时多出一些“幻影”行。这称为幻读 (Phantom Read)。 性能： MySQL InnoDB 存储引擎的默认隔离级别。它通过间隙锁 (Gap Lock) 在一定程度上解决了幻读问题。 可串行化 (Serializable):\n现象： 强制事务串行执行，即一个接一个地执行，完全避免了脏读、不可重复读和幻读问题。 问题： 并发性能最低，因为事务之间不能并行执行。 性能： 数据一致性最高，但并发能力最差。在对数据一致性要求极高且并发量不大的场景下可能使用。 选择哪个隔离级别？\n选择合适的隔离级别需要在数据一致性和系统并发性能之间进行权衡，根据具体的业务场景需求来决定。\n六、@Transactional注释 除了数据库层面直接使用SQL命令管理事务外，在应用开发中，我们通常会使用框架或特定的API来管理事务，这样可以更方便地将事务管理逻辑与业务逻辑解耦。\n@Transactional 的用法 Spring Framework 提供的一个注解，用于声明性地管理事务。它可以应用在类级别或方法级别。它会在方法运行之前，开启事务，运行完毕之后，根据运行结果，提交或回滚事务。\n位置（业务Service层）：\n方法级别： 推荐使用。适用于一个业务方法多次对数据进行增、删、改等操作。当注解在方法上时，该方法将作为一个事务单元执行。 类级别： 当注解在类上时，表示该类中所有 public 方法都将默认应用相同的事务配置。如果方法上也有 @Transactional 注解，则方法级别的配置会覆盖类级别的配置。 接口级别： 也可以注解在接口上，但不推荐，因为注解是不能被继承的，Spring 的事务是基于代理的，如果基于接口的代理（JDK动态代理），注解在接口上是有效的。但如果使用基于类的代理（CGLIB），注解在接口上是无效的。为了统一和避免混淆，建议注解在实现类或其方法上。 默认出现运行时异常（RunTimeException）才会回滚\n前面我们通过spring事务管理注解@Transactional已经控制了业务层方法的事务。接下来我们要来详细的介绍一下@Transactional事务管理注解的使用细节。我们这里主要介绍@Transactional注解当中的两个常见的属性：\n异常回滚的属性：rollbackFor\n事务传播行为：propagation\n我们先来学习下rollbackFor属性。\n1 @Transactional(rollbackFor = Exception.class)//所有异常都会回滚 Spring 事务传播行为 (Propagation Behavior) 举例： 当一个事务方法调用另一个事务方法时，Spring 的事务传播行为定义了第二个事务方法如何参与到现有事务中，或者如何开启新事务。常见的传播行为有：\nREQUIRED (默认): 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。 MANDATORY: 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 REQUIRES_NEW: 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。 NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。 NESTED: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与 REQUIRED 类似的操作。嵌套事务是外部事务的一部分，有自己的保存点，可以独立回滚而不影响外部事务，但外部事务回滚会影响嵌套事务。 七、分布式事务 - 进阶 当一个业务操作需要跨多个独立的数据库或服务时，就涉及到分布式事务。单个数据库的ACID特性无法直接保证跨多个资源的事务一致性。\n挑战： 多个参与者（数据库、消息队列等）的一致性难以保证。 网络延迟和故障增加了复杂性。 常见解决方案： 两阶段提交 (2PC - Two-Phase Commit): 准备阶段 (Prepare Phase): 协调者询问所有参与者是否可以提交事务。参与者执行事务操作，锁定资源，但不实际提交，并向协调者报告准备就绪或失败。 提交/回滚阶段 (Commit/Rollback Phase): 如果所有参与者都准备就绪，协调者通知所有参与者提交事务；否则，通知所有参与者回滚事务。 缺点： 同步阻塞、单点故障（协调者）、数据不一致（协调者宕机时）。 三阶段提交 (3PC - Three-Phase Commit): 2PC的改进，引入了超时机制和CanCommit阶段，减少了阻塞时间，但更复杂。 TCC (Try-Confirm-Cancel): 补偿型事务。 Try: 尝试执行业务，预留资源。 Confirm: 如果Try阶段所有参与者都成功，则执行Confirm操作，实际完成业务。 Cancel: 如果Try阶段有任何参与者失败，或者Confirm阶段某个参与者失败，则执行Cancel操作，回滚Try阶段预留的资源。 特点： 对业务代码侵入性强，需要业务层面实现Try, Confirm, Cancel三个接口。 Saga (Saga Pattern): 长事务解决方案。将一个大事务拆分成多个本地事务，每个本地事务都有对应的补偿操作。如果某个本地事务失败，则按相反顺序执行前面已成功事务的补偿操作。 基于消息队列的最终一致性： 通过消息队列异步通知相关服务执行操作，并通过重试、幂等性、补偿等机制最终达到数据一致性。 总结 事务管理是确保数据完整性和一致性的核心机制。理解其ACID特性、不同的隔离级别以及如何在应用中进行管理（声明式与编程式）是非常重要的。对于复杂系统，还需要考虑到分布式事务的挑战和解决方案。在实际开发中，我们会根据业务需求、性能要求和系统复杂度来选择合适的事务管理策略和技术。\n希望以上回答能够清晰地解释事务管理的相关知识点。这样的回答结构清晰，内容详尽，应该能够给面试官留下一个好印象。\n","date":"2025-05-17T17:16:37+08:00","image":"https://wp-cdn.4ce.cn/v2/nNDeTLC.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"事务管理的学习笔记"},{"content":"MyBatis分页查询与动态SQL学习笔记 一、分页查询的两种方式 1. 物理分页（推荐） 特点：\n在SQL层面实现分页 性能更好（大数据量场景） 常用实现方式：PageHelper插件、手写分页SQL 2. 逻辑分页 特点：\n查询全部数据后在内存中分页 性能较差（小数据量可用） 实现方式：RowBounds 二、实现案例 案例1：使用PageHelper插件（含动态SQL） 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;selectUsersByCondition\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM user \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; AND name LIKE CONCAT(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;status != null\u0026#34;\u0026gt; AND status = #{status} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; ORDER BY create_time DESC \u0026lt;/select\u0026gt; Java调用：\n1 2 3 PageHelper.startPage(1, 10); List\u0026lt;User\u0026gt; users = userMapper.selectUsersByCondition(params); PageInfo\u0026lt;User\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(users); 案例2：手写SQL分页（MySQL）与动态SQL结合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;select id=\u0026#34;selectByPageWithDynamic\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM user \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;role == \u0026#39;admin\u0026#39;\u0026#34;\u0026gt; AND department_id = #{deptId} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;role == \u0026#39;manager\u0026#39;\u0026#34;\u0026gt; AND team_id = #{teamId} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; AND status = 1 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; LIMIT #{offset}, #{pageSize} \u0026lt;/select\u0026gt; 三、动态SQL核心知识点 1. 常用标签 标签 作用 \u0026lt;if\u0026gt; 条件判断 \u0026lt;choose\u0026gt; 类似Java的switch-case \u0026lt;where\u0026gt; 自动处理WHERE关键字和AND/OR前缀 \u0026lt;set\u0026gt; 自动处理UPDATE语句的SET部分 \u0026lt;foreach\u0026gt; 遍历集合，常用于IN条件 \u0026lt;trim\u0026gt; 自定义字符串修剪（可替代where/set） \u0026lt;bind\u0026gt; 创建变量并绑定到上下文 2. 典型应用场景 场景1：多条件查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;select id=\u0026#34;findUsers\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM user \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; AND name LIKE #{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;minAge != null\u0026#34;\u0026gt; AND age \u0026gt;= #{minAge} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;statusList != null and statusList.size() \u0026gt; 0\u0026#34;\u0026gt; AND status IN \u0026lt;foreach collection=\u0026#34;statusList\u0026#34; item=\u0026#34;status\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{status} \u0026lt;/foreach\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 场景2：动态UPDATE 1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;updateUserSelective\u0026#34;\u0026gt; UPDATE user \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null\u0026#34;\u0026gt;email = #{email},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;status != null\u0026#34;\u0026gt;status = #{status}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; WHERE id = #{id} \u0026lt;/update\u0026gt; 场景3：批量插入 1 2 3 4 5 6 \u0026lt;insert id=\u0026#34;batchInsert\u0026#34;\u0026gt; INSERT INTO user (name, age) VALUES \u0026lt;foreach collection=\u0026#34;users\u0026#34; item=\u0026#34;user\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (#{user.name}, #{user.age}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; 四、面试常见问题与回答建议 Q1：MyBatis动态SQL的实现原理？ 回答要点：\n基于OGNL表达式解析 通过XML标签生成最终SQL 使用SqlNode和SqlSource构建动态SQL 示例回答：\n\u0026ldquo;MyBatis动态SQL通过解析XML中的特殊标签（如if/where等），根据参数值动态拼接SQL语句。底层使用OGNL表达式求值，最终生成StaticSqlSource或DynamicSqlSource对象。比如标签会智能处理AND/OR前缀，避免语法错误。\u0026rdquo;\nQ2：如何优化动态SQL的性能？ 回答建议：\n避免过度复杂的动态条件 使用替代手动WHERE 1=1 注意的批量操作数量控制 示例回答：\n\u0026ldquo;我们项目中对动态SQL的优化主要有：1) 对高频查询使用预处理模糊查询参数；2) 批量操作时控制的集合大小（分批次处理）；3) 复杂查询拆分为多个简单SQL，通过Java代码组合结果。\u0026rdquo;\nQ3：动态SQL和分页结合使用的注意事项？ 回答要点：\n确保分页在最终SQL上执行 PageHelper要放在动态SQL查询前 注意排序字段的索引优化 示例回答：\n\u0026ldquo;结合使用时需注意：1) PageHelper.startPage()必须在动态SQL查询前调用，确保分页是对最终结果集生效；2) 动态WHERE条件中的字段建议建立复合索引；3) 排序字段如果是动态的，需要防范SQL注入。\u0026rdquo;\n五、最佳实践总结 分页选择：\n常规场景用PageHelper 超大数据量考虑游标分页（基于索引） 动态SQL规范：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 推荐写法 --\u0026gt; \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;param != null\u0026#34;\u0026gt; AND column = #{param} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;!-- 不推荐写法 --\u0026gt; WHERE 1=1 \u0026lt;if test=\u0026#34;param != null\u0026#34;\u0026gt; AND column = #{param} \u0026lt;/if\u0026gt; 性能监控：\n开启MyBatis日志检查最终执行的SQL 对复杂动态SQL进行压测 💡 面试加分点：可以举例说明如何解决实际项目中遇到的动态SQL问题，例如：\u0026ldquo;我们曾遇到一个多条件导出功能，通过动态SQL减少70%的冗余代码，同时用PageHelper的count查询优化解决了分页总数性能问题。\u0026rdquo;\n","date":"2025-05-16T16:01:17+08:00","image":"https://wp-cdn.4ce.cn/v2/7GHIYWk.png","permalink":"https://gavin-gwj.github.io/hugo-dev/p/mybatis%E7%AF%87-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/","title":"MyBatis篇-分页查询"},{"content":"Java 类加载机制与双亲委派机制详解 一、类加载机制 1. 核心概念 类加载机制指 JVM 将.class字节码文件加载到内存，并对数据进行验证、解析、初始化，最终形成可被 JVM 直接使用的 Java 类型的过程。\n2. 加载流程 分为三个阶段，共七个步骤：\n阶段 步骤 说明 加载 1. 加载 读取字节码文件，创建 Class 对象 链接 2. 验证 验证字节码格式、安全性等 3. 准备 为静态变量分配内存并设置初始值（零值） 4. 解析 将符号引用转换为直接引用 初始化 5. 初始化 执行类构造器\u0026lt;clinit\u0026gt;()方法（静态代码块和静态变量赋值） 第一步：Loading 加载 通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流\n将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构\n在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n总结：加载二进制数据到内存 → 映射成JVM能识别的结构 → 在内存中生成Class文件。\n第二步：Linking 链接\n链接是指将上面创建好的 Class 类合并至 Java 虚拟机中，使之能够执行的过程，可分为验证、准备、解析三个阶段。 ① 验证（Verify）\n确保 class 文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的 class 类的正确性，不会危害到虚拟机的安全。\n② 准备（Prepare）\n为类中的静态字段分配内存，并设置默认的初始值，比如 int 类型初始值是 0。被final修饰的 static 字段不会设置，因为 final 在编译的时候就分配了\n③ 解析（Resolve）\n解析阶段的目的，是将常量池内的符号引用转换为直接引用的过程（将常量池内的符号引用解析成为实际引用）。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）\n事实上，解析器操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。\n第三步：Initialization 初始化 初始化就是执行类的构造器方法\u0026lt;clinit\u0026gt;()的过程。\n这个方法不需要定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。\n若该类具有父类，JVM会保证父类的\u0026lt;clinit\u0026gt;先执行，然后在执行子类的\u0026lt;clinit\u0026gt;。\n3. 触发时机 创建类实例（new） 访问静态变量 / 方法 反射调用（Class.forName ()） 子类被加载时父类未初始化 主类（包含 main () 方法的类） 二、双亲委派机制 1. 核心原理 工作流程：\n类加载请求首先委派给父类加载器 父加载器无法完成时（在自己的搜索范围内找不到），子加载器才会尝试加载 加载器层次：\n启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader） 自定义类加载器（User-Defined ClassLoader） 2. 优势特点 安全性：防止核心 API 被篡改（如自定义 java.lang.Object 类） 唯一性：保证类在各级加载器中只加载一次 高效性：避免重复加载带来的资源浪费 3. 源码实现 java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 1. 检查是否已加载 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { try { // 2. 委托父类加载 if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) {} // 3. 自行加载 if (c == null) { c = findClass(name); } } return c; } } 三、打破双亲委派机制 1. 实现方式 方法 说明 典型应用场景 自定义类加载器 重写loadClass()方法，改变委派逻辑 Tomcat 热部署 线程上下文类加载器 通过Thread.setContextClassLoader()指定加载器 JDBC 驱动加载 OSGi 模块化系统 采用网状委派模型 Eclipse 插件系统 SPI 服务发现机制 使用ServiceLoader加载实现类 Java 日志门面、数据库驱动 2. 代码示例：自定义类加载器 java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class CustomClassLoader extends ClassLoader { @Override protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 1. 检查自定义路径 if (name.startsWith(\u0026#34;com.myapp\u0026#34;)) { return findClass(name); } // 2. 其他类仍遵循双亲委派 return super.loadClass(name, resolve); } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) { // 自定义类加载逻辑... } } 3. 典型场景分析 Tomcat：为每个 Web 应用创建独立的 WebAppClassLoader\n隔离性：不同 Web 应用的类独立加载 热部署：通过重新创建类加载器实现 JDBC 驱动加载：\njava\n1 2 3 // 使用线程上下文类加载器 Connection conn = DriverManager.getConnection(url); // DriverManager在启动类加载器中，通过ContextClassLoader加载具体驱动 四、总结对比 机制 优点 缺点 适用场景 双亲委派 安全性高、避免重复加载 灵活性不足 常规 Java 应用开发 自定义类加载 灵活性强、支持热部署 可能引发类冲突 容器化环境、模块热加载 上下文类加载器 解决基础类回调用户代码问题 需要显式设置 SPI 扩展机制、跨类加载器调用 面试要点：理解双亲委派的核心设计思想，掌握主流框架打破委派的实现原理，能结合具体场景说明技术选型依据。\n","date":"2025-05-16T13:07:17+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/jvm%E7%AF%87-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","title":"JVM篇-类加载机制与双亲委派机制"},{"content":"Spring Boot 项目开发流程详解 (以员工管理为例) 这个案例开发流程是一个典型的基于 Spring Boot 的分层架构实现。下面我将详细阐述每个步骤及其核心思想，希望能让您对这个流程有一个清晰的理解。\n核心目标： 实现模块化、高内聚、低耦合，使得代码易于理解、维护、测试和扩展。\n流程总览：\n请求 (Request) → Controller 层 → Service 层 (接口+实现) → Mapper 层 (DAO) → 数据库 (Database) → Mapper 层 → Service 层 → Controller 层 → 响应 (Response)\n1. POJO 层 (Plain Old Java Object) / Entity 层 目的 定义数据模型，用于封装业务数据。这些类通常与数据库表结构相对应。\n具体实现 创建 Emp.java (员工信息实体类) 和 Empr.java (员工工作经历实体类)。\nEmp.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.pojo; import java.util.List; // 如果需要在Emp中直接持有Empr列表 // import lombok.Data; // 使用Lombok简化代码，可选 // @Data // Lombok注解，自动生成getter/setter/toString/equals/hashCode public class Emp { private Integer empId; private String empName; private String department; private Double salary; // private List\u0026lt;Empr\u0026gt; workExperiences; // 可选，用于一对多关系 // Standard getters and setters, constructor, toString, etc. // 如果不用Lombok，需要手动添加 public Integer getEmpId() { return empId; } public void setEmpId(Integer empId) { this.empId = empId; } // ... 其他属性的getter/setter } Empr.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.pojo; import java.util.Date; // import lombok.Data; // @Data public class Empr { // Employee Experience Record private Integer emprId; private Integer empId; // 外键，关联到Emp表的empId private String companyName; private String position; private Date startDate; private Date endDate; private String description; // Standard getters and setters, constructor, toString, etc. } 关键点 属性：与数据库表字段一一对应，或根据业务需求定义。 注解（可选，但常用）： Lombok: @Data, @Getter, @Setter, @ToString, @EqualsAndHashCode, @NoArgsConstructor, @AllArgsConstructor 等注解可以极大简化代码，避免手动编写样板代码。 JPA/MyBatis-Plus: 如果使用 JPA 或 MyBatis-Plus 等 ORM 框架，还会用到 @Entity, @Table, @Id, @Column, @TableId, @TableName 等注解来映射数据库表和字段。 封装性：属性通常声明为 private，通过 public 的 getter 和 setter 方法访问。 2. Mapper 层 (DAO - Data Access Object) 目的 定义数据访问接口，负责与数据库进行直接交互，执行 SQL 语句（增删改查）。\n具体实现 创建 EmpMapper.java 和 EmpEmprMapper.java 接口，并在接口上添加 @Mapper 注解。\n@Mapper 注解作用：\n这是 MyBatis 的注解 (或者是 MyBatis-Plus 提供的，效果类似)。 Spring Boot 在启动时会扫描带有 @Mapper 注解的接口，并为它们创建代理实现类，然后将这些代理实例注册到 Spring IOC 容器中。这样，在 Service 层就可以通过 @Autowired 自动注入这些 Mapper 接口的实例。 EmpMapper.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.mapper; import com.example.pojo.Emp; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; // 多个参数时建议使用 import java.util.List; @Mapper public interface EmpMapper { Emp findById(@Param(\u0026#34;empId\u0026#34;) Integer empId); List\u0026lt;Emp\u0026gt; findAll(); int insertEmp(Emp emp); int updateEmp(Emp emp); int deleteEmp(@Param(\u0026#34;empId\u0026#34;) Integer empId); } EmpEmprMapper.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.example.mapper; import com.example.pojo.Empr; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Param; import java.util.List; @Mapper public interface EmpEmprMapper { List\u0026lt;Empr\u0026gt; findByEmpId(@Param(\u0026#34;empId\u0026#34;) Integer empId); int insertEmpr(Empr empr); // ... 其他CRUD方法 } 关键点 接口定义：只定义方法签名，不包含具体实现。 SQL 实现： XML 文件：通常与 Mapper 接口同路径或在 resources 目录下创建对应的 XML 文件 (如 EmpMapper.xml) 来编写 SQL 语句。 注解方式：对于简单 SQL，也可以直接使用 @Select, @Insert, @Update, @Delete 等注解直接在接口方法上编写 SQL。 方法命名：通常遵循一定的规范，如 findByXXX, insertXXX, updateXXX, deleteXXX。 参数与返回：方法的参数对应 SQL 中的条件，返回值对应查询结果。 3. Service 层 目的 处理核心业务逻辑，对一个或多个 Mapper 操作进行编排和封装，形成一个完整的业务功能。它起到承上启下的作用，隔离 Controller 层和 Mapper 层。\n分为两部分：接口和实现类 3.1 Service 接口 (EmpService.java) 目的：定义业务契约，声明业务方法。这样做的好处是面向接口编程，提高代码的灵活性和可测试性 (方便 Mock)。\n具体实现：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.service; import com.example.pojo.Emp; // import com.example.dto.EmpDetailDTO; // 可能需要DTO import java.util.List; public interface EmpService { Emp getEmployeeById(Integer empId); // EmpDetailDTO getEmployeeWithExperience(Integer empId); // 示例：返回包含经历的员工信息 List\u0026lt;Emp\u0026gt; getAllEmployees(); void addNewEmployee(Emp emp /*, List\u0026lt;Empr\u0026gt; experiences*/); // 可能同时添加员工和经历 void updateEmployeeInfo(Emp emp); void removeEmployee(Integer empId); } 3.2 Service 实现类 (EmpServiceImpl.java) 目的：具体实现 Service 接口中定义的业务逻辑。\n具体实现：\n创建 impl 包 (约定俗成)，在包内创建 EmpServiceImpl.java 类。 实现 EmpService 接口 (implements EmpService)。 添加 @Service 注解。 @Service 注解作用：\n这是 Spring 框架的 stereotype (构造型) 注解之一，用于标识这是一个业务逻辑层组件。 Spring Boot 启动时会扫描带有 @Service 注解的类，并创建其实例注册到 Spring IOC 容器中，使其成为一个 Bean。这样，在 Controller 层就可以通过 @Autowired 自动注入 EmpService 接口的实例 (Spring 会自动找到其实现类 EmpServiceImpl 的实例)。 EmpServiceImpl.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 package com.example.service.impl; import com.example.mapper.EmpEmprMapper; import com.example.mapper.EmpMapper; import com.example.pojo.Emp; import com.example.pojo.Empr; import com.example.service.EmpService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; // 引入事务注解 import java.util.List; @Service // 声明为Spring IOC容器的Bean public class EmpServiceImpl implements EmpService { @Autowired // 自动注入EmpMapper实例 private EmpMapper empMapper; @Autowired // 自动注入EmpEmprMapper实例 private EmpEmprMapper empEmprMapper; @Override public Emp getEmployeeById(Integer empId) { // 简单示例：直接调用mapper return empMapper.findById(empId); } /* // 复杂业务示例：获取员工及其工作经历 @Override public EmpDetailDTO getEmployeeWithExperience(Integer empId) { Emp emp = empMapper.findById(empId); if (emp == null) { return null; } List\u0026lt;Empr\u0026gt; experiences = empEmprMapper.findByEmpId(empId); // 假设EmpDetailDTO是专门用于封装员工和其经历的类 EmpDetailDTO dto = new EmpDetailDTO(); dto.setEmpId(emp.getEmpId()); dto.setEmpName(emp.getEmpName()); // ... 其他emp属性 dto.setWorkExperiences(experiences); return dto; } */ @Override public List\u0026lt;Emp\u0026gt; getAllEmployees() { return empMapper.findAll(); } @Override @Transactional // 声明式事务：保证方法内多个数据库操作的原子性 public void addNewEmployee(Emp emp /*, List\u0026lt;Empr\u0026gt; experiences*/) { empMapper.insertEmp(emp); // 插入员工信息，emp对象通常会配置返回自增主键 // if (experiences != null \u0026amp;\u0026amp; !experiences.isEmpty()) { // for (Empr expr : experiences) { // expr.setEmpId(emp.getEmpId()); // 设置外键 // empEmprMapper.insertEmpr(expr); // } // } // 如果在插入经历时发生错误，整个操作会回滚 } @Override @Transactional public void updateEmployeeInfo(Emp emp) { empMapper.updateEmp(emp); // 可能还需要更新相关的工作经历等 } @Override @Transactional public void removeEmployee(Integer empId) { // 实际业务中可能需要先删除关联的工作经历，或有其他逻辑检查 // empEmprMapper.deleteByEmpId(empId); // 假设有此方法 empMapper.deleteEmp(empId); } } 关键点 依赖注入 (@Autowired)：通过 @Autowired 注解将 Mapper 层的实例注入到 Service 实现类中。 业务逻辑封装：包含条件判断、数据转换、多个 DAO 操作的组合等。 事务管理 (@Transactional)：对于涉及多个写操作（增、删、改）的业务方法，通常会使用 @Transactional 注解来保证操作的原子性。如果方法中任意一个数据库操作失败，整个事务会回滚，保证数据一致性。 4. Controller 层 目的 接收前端 HTTP 请求，调用 Service 层处理业务逻辑，并将处理结果返回给前端。它是应用的入口点。\n具体实现 创建 EmpController.java 类，并添加 @RestController 注解。\n@RestController 注解作用：\n这是一个组合注解，相当于 @Controller + @ResponseBody。 @Controller：将类标识为一个控制器组件，Spring IOC 容器会管理它。 @ResponseBody：表示该控制器中所有方法的返回值都会直接作为 HTTP 响应体的内容（通常是 JSON 或 XML 格式），而不是视图名称。 @Slf4j (可选)：\n这是 Lombok 提供的注解，用于快速集成 SLF4J 日志框架。它会在编译时自动为类添加一个 log 字段 ( private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(EmpController.class); )。 作用：方便记录日志，用于调试、追踪问题和监控应用运行状态。 EmpController.java 示例：\njava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package com.example.controller; import com.example.pojo.Emp; // import com.example.dto.EmpDetailDTO; import com.example.service.EmpService; import lombok.extern.slf4j.Slf4j; // 如果使用@Slf4j import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController // 声明为RESTful风格的控制器，方法返回JSON/XML @RequestMapping(\u0026#34;/api/employees\u0026#34;) // 类级别的请求路径映射，所有方法都在此基础路径下 @Slf4j // 可选，用于日志记录 public class EmpController { @Autowired // 自动注入EmpService实例 private EmpService empService; // GET /api/employees/{id} - 获取指定ID的员工信息 @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getEmployeeById(@PathVariable Integer id) { log.info(\u0026#34;Request to get employee with ID: {}\u0026#34;, id); // EmpDetailDTO empDetail = empService.getEmployeeWithExperience(id); Emp employee = empService.getEmployeeById(id); if (employee != null) { log.info(\u0026#34;Found employee: {}\u0026#34;, employee.getEmpName()); return ResponseEntity.ok(employee); // 返回200 OK 和员工数据 } else { log.warn(\u0026#34;Employee with ID: {} not found.\u0026#34;, id); return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\u0026#34;Employee not found\u0026#34;); // 返回404 Not Found } } // GET /api/employees - 获取所有员工信息 @GetMapping public ResponseEntity\u0026lt;List\u0026lt;Emp\u0026gt;\u0026gt; getAllEmployees() { log.info(\u0026#34;Request to get all employees\u0026#34;); List\u0026lt;Emp\u0026gt; employees = empService.getAllEmployees(); return ResponseEntity.ok(employees); } // POST /api/employees - 新增员工 @PostMapping public ResponseEntity\u0026lt;Emp\u0026gt; createEmployee(@RequestBody Emp emp /*, @RequestBody List\u0026lt;Empr\u0026gt; experiences (更复杂场景)*/) { log.info(\u0026#34;Request to create new employee: {}\u0026#34;, emp.getEmpName()); empService.addNewEmployee(emp /*, experiences*/); // 通常在emp对象中会包含数据库生成的ID，如果配置了MyBatis返回主键 return ResponseEntity.status(HttpStatus.CREATED).body(emp); // 返回201 Created 和创建的员工数据 } // PUT /api/employees/{id} - 更新指定ID的员工信息 @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; updateEmployee(@PathVariable Integer id, @RequestBody Emp emp) { log.info(\u0026#34;Request to update employee with ID: {}\u0026#34;, id); // 确保emp对象的id与路径变量id一致，或以路径变量为准 emp.setEmpId(id); empService.updateEmployeeInfo(emp); return ResponseEntity.ok(\u0026#34;Employee updated successfully\u0026#34;); } // DELETE /api/employees/{id} - 删除指定ID的员工 @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; deleteEmployee(@PathVariable Integer id) { log.info(\u0026#34;Request to delete employee with ID: {}\u0026#34;, id); empService.removeEmployee(id); return ResponseEntity.noContent().build(); // 返回204 No Content } } 关键点 依赖注入 (@Autowired)：注入 EmpService 实例。 请求映射注解： @RequestMapping(\u0026quot;/api/employees\u0026quot;): 定义类级别的基础 URL 路径。 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping: 分别对应 HTTP 的 GET, POST, PUT, DELETE 请求方法，并可指定具体的子路径 (如 /{id})。 参数绑定注解： @PathVariable: 从 URL 路径中提取参数 (如 /{id} 中的 id)。 @RequestBody: 将 HTTP 请求体中的 JSON/XML 数据自动转换为 Java 对象 (如 Emp 对象)。 @RequestParam: 从 URL 查询参数中提取值 (如 ?name=John)。 响应处理 (ResponseEntity)： 使用 ResponseEntity 可以更精细地控制 HTTP 响应，包括状态码、头部信息和响应体。 可以直接返回 POJO 对象，Spring MVC 会自动通过 HttpMessageConverter (如 JacksonHttpMessageConverter) 将其序列化为 JSON (默认) 或 XML。 RESTful API 设计：通常遵循 RESTful 风格来设计 API 接口。 总结与强调 分层解耦：每一层都有明确的职责，Controller 负责调度和 HTTP 交互，Service 负责业务逻辑，Mapper 负责数据持久化。这种分离使得各层可以独立开发、测试和修改，降低了模块间的耦合度。 Spring IOC (Inversion of Control)：通过 @Mapper, @Service, @RestController 等注解，我们将对象的创建和管理的权力交给了 Spring 容器。我们需要使用某个组件时，通过 @Autowired 进行依赖注入即可，无需手动 new 对象，这简化了对象管理和依赖关系。 面向接口编程：尤其是在 Service 层，通过定义接口和实现类，可以提高系统的灵活性和可扩展性。例如，未来如果需要更换 EmpServiceImpl 的实现，只要新的实现类也实现了 EmpService 接口，Controller 层的代码基本无需改动。 声明式事务：通过在 Service 层方法上使用 @Transactional 注解，可以优雅地实现事务管理，而无需编写冗余的事务控制代码。 Lombok (可选但推荐)：通过 @Data, @Slf4j 等注解，可以减少大量的样板代码，使代码更简洁易读。 这个流程是 Spring Boot Web 应用开发中非常经典和常用的一种实践。它清晰地划分了不同组件的职责，使得项目结构更加规范，易于团队协作和长期维护。\n","date":"2025-05-15T16:13:33+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spring-boot-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%A1%86%E6%9E%B6%E5%92%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/","title":"Spring Boot 项目搭建框架和流程详解"},{"content":"Java String 相等性判断：深入解析与面试攻略 这是一道经典的 Java String 面试题，旨在考察开发者对 String 对象在内存中的创建方式、String Constant Pool、== 操作符的行为以及编译器优化（特别是常量折叠）的理解。\n问题描述 请分析下面这段 Java 代码的输出结果：\nJava\n1 2 3 4 5 6 7 8 9 10 11 public class Main { public static void main(String[] args) { String a = \u0026#34;xiaoming2\u0026#34;; final String b = \u0026#34;xiaoming\u0026#34;; String d = \u0026#34;xiaoming\u0026#34;; String c = b + 2; String e = d + 2; System.out.println(a == c); System.out.println(a == e); } } 预期输出 1 2 true false 面试应对策略与详细解析 在面试中遇到这类问题时，一个好的回答应该结构清晰，层层递进，不仅给出答案，更能深入解释背后的原理。\n1. 确认问题并给出输出 首先，清晰地向面试官确认理解了问题，并直接给出代码的运行结果。\n面试官，您好。这段代码的输出结果是：\n1 2 true false 2. 解释原因：核心概念 接下来，详细阐述导致这一结果的关键 Java 概念。这是回答中最核心的部分。\nString Constant Pool (字符串常量池): 这是 Java 堆内存中的一块特殊区域，用于存储字符串字面量。当使用字面量（如 \u0026quot;abc\u0026quot;）创建 String 对象时，JVM 会优先在常量池中查找是否有内容相等的字符串。如果找到，则直接返回该对象的引用；如果找不到，则在常量池中创建新的 String 对象并返回引用。 == 操作符: 对于对象类型，== 比较的是两个引用变量是否指向内存中的同一个对象（即比较对象的内存地址）。 equals() 方法: String 类重写了 Object 类的 equals() 方法，用于比较两个字符串对象的内容是否相等。在实际开发中，比较字符串内容时务必使用 equals()。 String Concatenation (+): 字符串拼接操作。在 Java 中，使用 + 进行字符串拼接时，如果操作数不是编译时常量，通常会在运行时通过 StringBuilder（或 StringBuffer）来实现，生成新的 String 对象。 Constant Folding (常量折叠): 这是 Java 编译器的一项重要优化技术。如果一个表达式的结果在编译时就可以完全确定（即表达式只包含字面量或被 final 修饰且初始化为常量的变量），编译器会在编译阶段直接计算出结果，而不是等到运行时。对于字符串拼接，如果参与拼接的都是编译时常量，编译器会直接将拼接结果放入常量池。 3. 结合代码分步分析 将上述概念应用于具体的代码行，解释每个 String 变量是如何创建的，以及它们引用的是内存中的哪个位置。\nString a = \u0026quot;xiaoming2\u0026quot;;: a 引用常量池中的字符串字面量 \u0026quot;xiaoming2\u0026quot;。 final String b = \u0026quot;xiaoming\u0026quot;;: b 引用常量池中的字符串字面量 \u0026quot;xiaoming\u0026quot;。由于 b 被 final 修饰且直接赋值为常量，b 的值在编译时是确定的常量。 String d = \u0026quot;xiaoming\u0026quot;;: d 引用常量池中的字符串字面量 \u0026quot;xiaoming\u0026quot;。它与 b 引用的是同一个对象。但 d 不是 final 的。 String c = b + 2;: 这是字符串拼接。因为 b 是一个 final 变量且其值是编译时常量，编译器会对其执行 常量折叠。它在编译时就将 b + 2 计算为 \u0026quot;xiaoming\u0026quot; + \u0026quot;2\u0026quot;，结果是 \u0026quot;xiaoming2\u0026quot;。这行代码编译后实际上等同于 String c = \u0026quot;xiaoming2\u0026quot;;。因此，c 也引用常量池中 \u0026quot;xiaoming2\u0026quot; 这个对象，与 a 引用的是同一个对象。 String e = d + 2;: 这也是字符串拼接。但 d 不是 final 变量。即使其值在此处看来是常量，编译器无法保证非 final 变量在运行时不变。因此，编译器 不会 对 d + 2 执行常量折叠。这个拼接操作会在运行时通过 StringBuilder 完成，生成一个新的 \u0026quot;xiaoming2\u0026quot; 字符串对象，这个新对象位于 堆内存 中，而不是常量池。e 引用这个新的堆对象。 4. 解释 == 比较结果 基于前面的分析，解释 == 比较的结果。\nSystem.out.println(a == c);\na 引用常量池中的 \u0026quot;xiaoming2\u0026quot; 对象。 c (经过常量折叠) 引用常量池中的 \u0026quot;xiaoming2\u0026quot; 对象。 因为 a 和 c 指向内存中的同一个对象，所以 a == c 的结果是 true。 System.out.println(a == e);\na 引用常量池中的 \u0026quot;xiaoming2\u0026quot; 对象。 e 引用运行时在堆中新创建的 \u0026quot;xiaoming2\u0026quot; 对象。 因为 a 和 e 指向内存中的不同对象，所以 a == e 的结果是 false。 5. 强调最佳实践 最后，简要说明在实际开发中比较字符串的最佳实践，体现良好的编程习惯。\n在实际开发中，我们通常只关心字符串的内容是否相等，而不是它们是否是内存中的同一个对象。因此，比较字符串内容时，应该始终使用 equals() 方法，例如 a.equals(e)。这会返回 true，因为它们的内容确实相同。\n相似的 String 面试案例 这类问题有很多变体，理解核心概念后，可以触类旁通。以下是一些常见的相似案例：\n案例 1: new String() 创建的对象 Java\n1 2 3 4 5 6 7 8 9 String s1 = \u0026#34;hello\u0026#34;; // 常量池 String s2 = \u0026#34;hello\u0026#34;; // 常量池 (与 s1 同一个) String s3 = new String(\u0026#34;hello\u0026#34;); // 堆中新对象 (内容是 \u0026#34;hello\u0026#34;) String s4 = new String(\u0026#34;hello\u0026#34;); // 堆中另一个新对象 (内容是 \u0026#34;hello\u0026#34;) System.out.println(s1 == s2); // true (同是常量池对象) System.out.println(s1 == s3); // false (常量池 vs 堆对象) System.out.println(s3 == s4); // false (堆中不同对象) System.out.println(s1.equals(s3)); // true (内容相同) 案例 2: intern() 方法的使用 intern() 方法会检查字符串对象的内容是否已存在于常量池。如果存在，则返回常量池中该对象的引用；如果不存在，则将该对象的内容放入常量池，并返回常量池中的引用。\nJava\n1 2 3 4 5 6 7 8 String s5 = new String(\u0026#34;world\u0026#34;).intern(); // 在堆中创建 \u0026#34;world\u0026#34;，然后将 \u0026#34;world\u0026#34; 放入/查找常量池，并返回常量池引用 String s6 = \u0026#34;world\u0026#34;; // 常量池 System.out.println(s5 == s6); // true (都引用常量池中的 \u0026#34;world\u0026#34;) String s7 = new String(\u0026#34;java\u0026#34;); // 堆中新对象 System.out.println(s7 == \u0026#34;java\u0026#34;); // false (堆 vs 常量池) System.out.println(s7.intern() == \u0026#34;java\u0026#34;); // true (intern() 返回常量池引用，与 \u0026#34;java\u0026#34; 字面量相同) 案例 3: 字面量拼接的常量折叠 如果拼接操作的左右两边都是字符串字面量，编译器会直接进行常量折叠。\nJava\n1 2 3 4 5 6 7 8 String partA = \u0026#34;abc\u0026#34;; String partB = \u0026#34;def\u0026#34;; String s8 = \u0026#34;abcdef\u0026#34;; // 常量池 String s9 = \u0026#34;abc\u0026#34; + \u0026#34;def\u0026#34;; // 编译器直接计算为 \u0026#34;abcdef\u0026#34;，放入常量池 (与 s8 同一个) String s10 = partA + partB; // partA, partB 不是 final，运行时拼接，生成堆对象 System.out.println(s8 == s9); // true (都指向常量池的 \u0026#34;abcdef\u0026#34;) System.out.println(s8 == s10); // false (常量池 vs 堆对象) 详细解析 为了理解为什么 s7 == s9 的结果是 false，我们需要再次强调 常量折叠 这个概念，以及它在哪些情况下会发生。\nString s7 = \u0026quot;abcdef\u0026quot;;\n这是一个简单的字符串字面量。 JVM 会在 字符串常量池 中查找是否存在内容为 \u0026quot;abcdef\u0026quot; 的字符串。 如果不存在，则在常量池中创建一个新的 \u0026quot;abcdef\u0026quot; 对象。 如果存在（或者刚刚创建了），则 s7 变量将引用 常量池 中的这个 \u0026quot;abcdef\u0026quot; 对象。 String s8 = \u0026quot;abc\u0026quot; + \u0026quot;def\u0026quot;;\n这是一个字符串拼接操作，但它的特别之处在于，参与拼接的 \u0026quot;abc\u0026quot; 和 \u0026quot;def\u0026quot; 都直接是 字符串字面量。 关键点： Java 编译器有一项优化叫做 常量折叠 (Constant Folding)。当编译器发现一个表达式完全由编译时常量组成时，它会在编译阶段就计算出表达式的结果。字符串字面量（如 \u0026quot;abc\u0026quot; 和 \u0026quot;def\u0026quot;）就是编译时常量。 因此，对于 \u0026quot;abc\u0026quot; + \u0026quot;def\u0026quot; 这个表达式，编译器在编译时就直接将其计算为 \u0026quot;abcdef\u0026quot;。 所以，String s8 = \u0026quot;abc\u0026quot; + \u0026quot;def\u0026quot;; 在编译后的字节码中，实际上就等同于 String s8 = \u0026quot;abcdef\u0026quot;;。 这意味着 s8 也引用 字符串常量池 中的 \u0026quot;abcdef\u0026quot; 对象。 结论： s7 和 s8 都引用常量池中的同一个 \u0026quot;abcdef\u0026quot; 对象。因此，s7 == s8 的结果是 true。 String s9 = part1 + part2;\n这也是一个字符串拼接操作，但参与拼接的是变量 part1 和 part2。 part1 引用常量池中的 \u0026quot;abc\u0026quot;。 part2 引用常量池中的 \u0026quot;def\u0026quot;。 关键点： 尽管在当前代码的上下文里，part1 和 part2 似乎看起来是“不变”的，但它们并没有被 final 关键字修饰。对于编译器来说，它 无法 确定 part1 和 part2 的值在程序运行时是否会改变。 由于表达式 part1 + part2 包含了 非编译时常量（因为它使用了非 final 变量），编译器 不会 对其进行常量折叠。 这个拼接操作会在 运行时 执行。在运行时，Java 通常使用 StringBuilder（或在旧版本中使用 StringBuffer）来执行字符串拼接。 运行时会大概执行类似这样的逻辑：new StringBuilder().append(part1).append(part2).toString(); StringBuilder 的 toString() 方法会创建一个 全新的 String 对象，这个新对象位于 堆内存 中（而不是常量池），其内容是 \u0026quot;abcdef\u0026quot;。 s9 变量将引用这个 新创建的、位于堆内存中 的 \u0026quot;abcdef\u0026quot; 对象。 结论： s9 引用的是一个运行时在堆中创建的新对象，而 s7 (和 s8) 引用的是常量池中的对象。它们是内存中的两个不同的对象。因此，s7 == s9 的结果是 false。 总结案例 3 的核心差异 案例 3 的关键在于区分两种拼接方式：\n\u0026quot;字面量A\u0026quot; + \u0026quot;字面量B\u0026quot;：编译器能确定结果，执行常量折叠，结果是常量池中的 \u0026quot;字面量A字面量B\u0026quot; 对象。 变量A + 变量B (变量 A 或 B 不是 final 或不是编译时常量)：编译器不能确定结果，留待运行时通过 StringBuilder 拼接，结果是在堆中创建的 新 对象。 这就是为什么 s8 (字面量拼接) 与 s7 (直接字面量) 指向同一个常量池对象，而 s9 (变量拼接) 指向堆中新对象的原因。\n案例 4: final 变量拼接的常量折叠 (与原题核心原理相同) Java\n1 2 3 4 5 6 final String FINAL_PART_1 = \u0026#34;compile\u0026#34;; final String FINAL_PART_2 = \u0026#34;time\u0026#34;; String s11 = \u0026#34;compilertime\u0026#34;; // 常量池 String s12 = FINAL_PART_1 + FINAL_PART_2; // final 变量拼接，编译器常量折叠为 \u0026#34;compilertime\u0026#34;，放入常量池 (与 s11 同一个) System.out.println(s11 == s12); // true (都指向常量池的 \u0026#34;compilertime\u0026#34;) 通过深入理解 String Constant Pool、== 与 equals() 的区别，以及编译器对 final 常量进行的优化（常量折叠），可以清晰地分析这类 String 相等性判断问题。记住：对于字符串内容的比较，永远优先使用 equals() 方法。\n","date":"2025-05-14T20:16:33+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E-final-%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","title":"Java 字符串常量池与 final 关键字深度解析"},{"content":"Spring Boot 三层架构 CRUD 与前后端联调笔记 (MyBatis 风格 Mapper) 1. 核心概念：三层架构 在典型的 Web 应用中，我们将后端逻辑划分为三个主要层次：\nController (控制层/表现层):\n职责: 接收前端发送的 HTTP 请求，对请求参数进行初步校验和转换。 调用 Service 层处理业务逻辑。 将 Service 层返回的结果封装成 HTTP 响应（通常是 JSON 格式）返回给前端。 直接与外界（如浏览器、App 或其他服务）打交道。 Service (服务层/业务逻辑层):\n职责: 实现核心业务逻辑。 组合调用一个或多个 Mapper/Repository 层的方法来完成复杂的业务操作。 处理事务管理。 不直接与 HTTP 请求或数据库打交道，而是作为 Controller 和 Mapper 之间的桥梁。 Mapper (数据访问层/持久层):\n职责: 与数据库进行直接交互，执行 SQL 语句（在此示例中，我们使用 MyBatis 风格的注解）。 提供原子性的数据操作方法（增、删、改、查）。 数据流向 (请求): 前端 -\u0026gt; Controller -\u0026gt; Service -\u0026gt; Mapper -\u0026gt; 数据库 数据流向 (响应): 数据库 -\u0026gt; Mapper -\u0026gt; Service -\u0026gt; Controller -\u0026gt; 前端\n2. 技术栈简介 Spring Boot: 用于快速搭建和运行 Java 应用。 Maven: 项目构建和依赖管理。 Lombok: (可选, 本笔记中未显式在 Dept 类使用，但推荐) 通过注解减少 Java 代码的冗余。 MySQL: 关系型数据库。 MyBatis: (通过注解方式) 持久层框架，直接编写 SQL。 3. 前提：实体类与结果类 假设我们有如下实体类 Dept.java 和一个通用的返回结果类 Result.java。\nDept.java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // package com.example.myapp.entity; // 假设的包名 import java.time.LocalDateTime; // (为简化，省略 Lombok 注解，实际项目中推荐使用 @Data, @NoArgsConstructor, @AllArgsConstructor) public class Dept { private Integer id; private String name; private LocalDateTime createTime; private LocalDateTime updateTime; // Standard getters and setters public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getCreateTime() { return createTime; } public void setCreateTime(LocalDateTime createTime) { this.createTime = createTime; } public LocalDateTime getUpdateTime() { return updateTime; } public void setUpdateTime(LocalDateTime updateTime) { this.updateTime = updateTime; } @Override public String toString() { return \u0026#34;Dept{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, createTime=\u0026#34; + createTime + \u0026#34;, updateTime=\u0026#34; + updateTime + \u0026#39;}\u0026#39;; } } Result.java:\nJava\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // package com.example.myapp.util; // 假设的包名 public class Result { private Integer code; // 1 for success, 0 for error (或其他自定义状态码) private String msg; private Object data; // 私有构造，防止直接实例化 private Result() {} public static Result success(Object data) { Result r = new Result(); r.code = 1; // 假设 1 代表成功 r.msg = \u0026#34;操作成功\u0026#34;; r.data = data; return r; } public static Result success() { Result r = new Result(); r.code = 1; r.msg = \u0026#34;操作成功\u0026#34;; return r; } public static Result error(String msg) { Result r = new Result(); r.code = 0; // 假设 0 代表失败 r.msg = msg; return r; } // Standard getters and setters public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } (请确保以上类已正确配置 getters 和 setters，如果使用 Lombok，则会自动生成)\n4. CRUD 操作步骤详解 4.1 查询部门 (根据ID - Read/Get) 步骤 1: Controller 层 (DeptController.java)\n定义一个处理 GET 请求的方法，通过路径变量接收 id。 调用 deptService.getById(id)。 返回 Result.success(dept)。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // package com.example.myapp.controller; // 假设的包名 import com.example.myapp.entity.Dept; import com.example.myapp.service.DeptService; import com.example.myapp.util.Result; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class DeptController { @Autowired private DeptService deptService; @GetMapping(\u0026#34;/depts/{id}\u0026#34;) public Result getInfo(@PathVariable Integer id){ System.out.println(\u0026#34;根据ID查询部门 : \u0026#34; + id); Dept dept = deptService.getById(id); // 调用 Service 层 if (dept != null) { return Result.success(dept); } return Result.error(\u0026#34;未找到ID为 \u0026#34; + id + \u0026#34; 的部门\u0026#34;); } } 步骤 2: Service 接口 (DeptService.java)\n在 DeptController.java 中的 deptService.getById(id) 上使用 Alt+Enter (IDEA 快捷键) 或手动创建方法。 定义 getById(Integer id) 接口方法。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 13 // package com.example.myapp.service; // 假设的包名 import com.example.myapp.entity.Dept; import java.util.List; // 为后续 listAll 方法准备 public interface DeptService { Dept getById(Integer id); // 后续会添加其他方法 List\u0026lt;Dept\u0026gt; listAll(); void addDept(Dept dept); void updateDept(Dept dept); void deleteDeptById(Integer id); } 步骤 3: Service 实现类 (DeptServiceImpl.java)\n在 DeptService 接口名上点击左侧绿色小箭头跳转到实现类，或手动创建。 实现 getById(Integer id) 方法。 调用 deptMapper.getById(id)。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // package com.example.myapp.service.impl; // 假设的包名 import com.example.myapp.entity.Dept; import com.example.myapp.mapper.DeptMapper; import com.example.myapp.service.DeptService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; // 为后续 listAll 方法准备 import java.time.LocalDateTime; // 为后续 add/update 方法准备 @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public Dept getById(Integer id) { return deptMapper.getById(id); // 调用 Mapper 层 } // 后续会实现其他方法 @Override public List\u0026lt;Dept\u0026gt; listAll() { // 待实现 return deptMapper.findAll(); } @Override public void addDept(Dept dept) { // 待实现 dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.insert(dept); } @Override public void updateDept(Dept dept) { // 待实现 dept.setUpdateTime(LocalDateTime.now()); deptMapper.update(dept); } @Override public void deleteDeptById(Integer id) { // 待实现 deptMapper.deleteById(id); } } 步骤 4: Mapper 接口 (DeptMapper.java)\n在 DeptServiceImpl.java 中的 deptMapper.getById(id) 上使用 Alt+Enter 或手动创建方法。 定义 getById(Integer id) 接口方法。 使用 @Select 注解编写 SQL 查询语句。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // package com.example.myapp.mapper; // 假设的包名 import com.example.myapp.entity.Dept; import org.apache.ibatis.annotations.*; import java.util.List; // 为后续 findAll 方法准备 @Mapper public interface DeptMapper { // 根据id查询部门 @Select(\u0026#34;SELECT id, name, create_time , update_time from depts WHERE id = #{id}\u0026#34;) Dept getById(Integer id); // 后续会添加其他方法 @Select(\u0026#34;SELECT id, name, create_time, update_time FROM depts\u0026#34;) List\u0026lt;Dept\u0026gt; findAll(); @Insert(\u0026#34;INSERT INTO depts (name, create_time, update_time) VALUES (#{name}, #{createTime}, #{updateTime})\u0026#34;) @Options(useGeneratedKeys = true, keyProperty = \u0026#34;id\u0026#34;) // 如果需要返回自增ID void insert(Dept dept); @Update(\u0026#34;UPDATE depts SET name = #{name}, update_time = #{updateTime} WHERE id = #{id}\u0026#34;) void update(Dept dept); @Delete(\u0026#34;DELETE FROM depts WHERE id = #{id}\u0026#34;) void deleteById(Integer id); } 4.2 查询所有部门 (Read All/List) 步骤 1: Controller 层 (DeptController.java)\n定义一个处理 GET 请求的方法，例如 /depts。 调用 deptService.listAll()。 返回 Result.success(deptList)。 Java\n1 2 3 4 5 6 7 8 9 // 在 DeptController.java 中添加 // import java.util.List; // 确保已导入 @GetMapping(\u0026#34;/depts\u0026#34;) public Result listAllDepts() { System.out.println(\u0026#34;查询所有部门\u0026#34;); List\u0026lt;Dept\u0026gt; deptList = deptService.listAll(); // 调用 Service 层 return Result.success(deptList); } 步骤 2: Service 接口 (DeptService.java)\n(已在上面 getById 部分的 DeptService.java 中定义 List\u0026lt;Dept\u0026gt; listAll();) 步骤 3: Service 实现类 (DeptServiceImpl.java)\n(已在上面 getById 部分的 DeptServiceImpl.java 中初步实现，调用 deptMapper.findAll()) 步骤 4: Mapper 接口 (DeptMapper.java)\n(已在上面 getById 部分的 DeptMapper.java 中定义 List\u0026lt;Dept\u0026gt; findAll(); 并使用 @Select 注解) 4.3 添加部门 (Create/Add) 步骤 1: Controller 层 (DeptController.java)\n定义一个处理 POST 请求的方法，例如 /depts，通过 @RequestBody 接收部门信息。 调用 deptService.addDept(dept)。 返回 Result.success()。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 // 在 DeptController.java 中添加 // import org.springframework.web.bind.annotation.PostMapping; // import org.springframework.web.bind.annotation.RequestBody; // 确保已导入 @PostMapping(\u0026#34;/depts\u0026#34;) public Result addDept(@RequestBody Dept dept) { System.out.println(\u0026#34;添加部门: \u0026#34; + dept.getName()); deptService.addDept(dept); // 调用 Service 层 // 如果 service 层或 mapper 层返回了带 ID 的对象，可以将其放入 Result // 例如: Dept createdDept = deptService.addDept(dept); return Result.success(createdDept); return Result.success(); } 步骤 2: Service 接口 (DeptService.java)\n(已在上面 getById 部分的 DeptService.java 中定义 void addDept(Dept dept);) 步骤 3: Service 实现类 (DeptServiceImpl.java)\n(已在上面 getById 部分的 DeptServiceImpl.java 中初步实现，设置时间并调用 deptMapper.insert(dept)) 步骤 4: Mapper 接口 (DeptMapper.java)\n(已在上面 getById 部分的 DeptMapper.java 中定义 void insert(Dept dept); 并使用 @Insert 和 @Options 注解) 4.4 修改部门 (Update) 步骤 1: Controller 层 (DeptController.java)\n定义一个处理 PUT 请求的方法，例如 /depts 或 /depts/{id}，通过 @RequestBody 接收更新的部门信息。 调用 deptService.updateDept(dept)。 返回 Result.success()。 Java\n1 2 3 4 5 6 7 8 9 10 11 12 // 在 DeptController.java 中添加 // import org.springframework.web.bind.annotation.PutMapping; // 确保已导入 @PutMapping(\u0026#34;/depts\u0026#34;) // 通常 PUT 请求体中应包含 ID public Result updateDept(@RequestBody Dept dept) { if (dept.getId() == null) { return Result.error(\u0026#34;更新部门时必须提供部门ID\u0026#34;); } System.out.println(\u0026#34;修改部门ID: \u0026#34; + dept.getId() + \u0026#34;, 新名称: \u0026#34; + dept.getName()); deptService.updateDept(dept); // 调用 Service 层 return Result.success(); } 步骤 2: Service 接口 (DeptService.java)\n(已在上面 getById 部分的 DeptService.java 中定义 void updateDept(Dept dept);) 步骤 3: Service 实现类 (DeptServiceImpl.java)\n(已在上面 getById 部分的 DeptServiceImpl.java 中初步实现，设置更新时间并调用 deptMapper.update(dept)) 步骤 4: Mapper 接口 (DeptMapper.java)\n(已在上面 getById 部分的 DeptMapper.java 中定义 void update(Dept dept); 并使用 @Update 注解) 4.5 删除部门 (Delete) 步骤 1: Controller 层 (DeptController.java)\n定义一个处理 DELETE 请求的方法，例如 /depts/{id}，通过 @PathVariable 接收 id。 调用 deptService.deleteDeptById(id)。 返回 Result.success()。 Java\n1 2 3 4 5 6 7 8 9 // 在 DeptController.java 中添加 // import org.springframework.web.bind.annotation.DeleteMapping; // 确保已导入 @DeleteMapping(\u0026#34;/depts/{id}\u0026#34;) public Result deleteDept(@PathVariable Integer id) { System.out.println(\u0026#34;删除部门ID: \u0026#34; + id); deptService.deleteDeptById(id); // 调用 Service 层 return Result.success(); } 步骤 2: Service 接口 (DeptService.java)\n(已在上面 getById 部分的 DeptService.java 中定义 void deleteDeptById(Integer id);) 步骤 3: Service 实现类 (DeptServiceImpl.java)\n(已在上面 getById 部分的 DeptServiceImpl.java 中初步实现，调用 deptMapper.deleteById(id)) 步骤 4: Mapper 接口 (DeptMapper.java)\n(已在上面 getById 部分的 DeptMapper.java 中定义 void deleteById(Integer id); 并使用 @Delete 注解) 5. 总结与展望 本笔记通过简单的部门 (Dept) 管理示例，展示了如何在 Spring Boot 项目中搭建 Controller、Service、Mapper (MyBatis 注解风格) 三层架构，并实现基本的增删改查操作。每一步都力求清晰，模拟了使用 IDE (如 IntelliJ IDEA) 开发时，从上层到底层逐层定义接口和实现的过程。\n前后端联调关键点:\nController 层是桥梁: 前端通过 HTTP 请求（如 GET, POST, PUT, DELETE）访问 Controller 中定义的 URL 路径。 数据格式: 前后端通常使用 JSON 格式交换数据。@RequestBody 用于接收前端发送的 JSON 数据，@RestController (或 @ResponseBody) 会自动将 Java 对象转换为 JSON 响应。 请求参数: @PathVariable 用于获取 URL 路径中的参数 (如 /depts/{id} 中的 id)。 @RequestParam 用于获取查询参数 (如 /depts/search?name=研发部 中的 name)。 @RequestBody 用于获取请求体中的数据 (通常是 POST, PUT 请求中的 JSON 对象)。 响应结果: 后端通过 Result 对象封装操作结果（成功/失败信息、数据）返回给前端。前端根据 Result 中的 code 和 msg 判断操作状态，并使用 data 渲染页面或进行其他处理。 API 测试工具: 在没有前端页面的情况下，可以使用 Postman、Insomnia 等工具测试后端 API 接口的正确性。 在实际项目中，还需要深入考虑：\n更完善的异常处理机制 (如全局异常处理器 @ControllerAdvice)。 Spring 的事务管理 (@Transactional) 的精细化使用。 输入参数校验 (如使用 javax.validation 或 Spring Validation)。 安全性 (如 Spring Security 进行认证和授权)。 更复杂的业务逻辑和数据库查询。 日志记录。 单元测试和集成测试。 希望这份笔记对您有所帮助！\n","date":"2025-05-14T15:36:34+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/spring-boot-%E7%AE%80%E5%8D%95%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/","title":"Spring Boot 简单的增删改查功能的实现"},{"content":"E-R图学习笔记 1. 概述 实体-联系模型 (E-R模型) 是一种用于数据库设计的概念模型，它提供了一种描述数据结构的高层视图，独立于任何特定的数据库管理系统 (DBMS)。E-R模型使用实体、属性和联系来表示现实世界中的数据及其相互关系。\n主要目标：\n清晰地表示数据需求。 为后续的数据库逻辑设计提供基础。 促进数据库设计者和用户之间的沟通。 2. 基本概念 2.1 实体 (Entity) 定义： 现实世界中可以区分的、独立存在的“事物”或“对象”。例如：学生、课程、教师、部门等。 表示： 通常用矩形框表示，框内写明实体的名称。 1 2 3 +----------+ | 学生 | +----------+ 2.2 属性 (Attribute) 定义： 描述实体特征的性质。例如：学生的学号、姓名、年龄；课程的课程号、课程名、学分等。 表示： 通常用椭圆表示，并用直线连接到所属的实体。属性名写在椭圆内。 1 2 3 4 5 6 7 8 +----------+ | 学生 | +----------+ / | \\ / | \\ +-------+ +-------+ +-------+ | 学号 | | 姓名 | | 年龄 | +-------+ +-------+ +-------+ 属性类型： 简单属性 (Simple Attribute)： 不能再分解为更小部分的属性，如年龄。 复合属性 (Composite Attribute)： 可以分解为更小部分的属性，如地址 (可以分解为省、市、街道等)。 多值属性 (Multivalued Attribute)： 对于一个实体实例可以有多个值的属性，如一个学生可以有多个兴趣爱好。通常用双层椭圆表示。 1 2 3 4 5 6 7 +----------+ | 学生 | +----------+ | +----------+ | 兴趣爱好 | +----------+ 派生属性 (Derived Attribute)： 其值可以从其他属性计算得到的属性，如学生的年龄可以从出生日期计算得到。通常用虚线椭圆表示。 1 2 3 4 5 6 7 +----------+ | 学生 | +----------+ | +----------+ | 年龄 | (派生) +----------+ 主键 (Primary Key)： 唯一标识一个实体实例的一个或一组属性。通常在属性名下方加下划线表示。一个实体只能有一个主键。 1 2 3 4 5 6 7 8 9 +----------+ | 学生 | +----------+ / | \\ / | \\ +--------+ +-------+ +-------+ | 学号 | | 姓名 | | 年龄 | +--------+ +-------+ +-------+ ------- 候选键 (Candidate Key)： 可以唯一标识一个实体实例的一个或一组属性。一个实体可以有多个候选键，但只能选择一个作为主键。 2.3 联系 (Relationship) 定义： 实体之间的关联或相互作用。例如：学生选修课程，教师教授课程，部门拥有员工等。 表示： 通常用菱形框表示，框内写明联系的名称，并用直线连接到相关的实体。 1 2 3 +----------+ +----------+ | 学生 |--------| 选修 |--------| 课程 | +----------+ +----------+ +----------+ 2.4 联系的度 (Cardinality) 描述参与联系的实体实例之间的数量关系，也称为基数比率。常见的基数比率有： 一对一 (1:1)： 实体集A中的每个实体最多与实体集B中的一个实体相关联，反之亦然。 1 2 3 +-----+ 1:1 +-----+ | A |-------------| B | +-----+ +-----+ 一对多 (1:N)： 实体集A中的每个实体可以与实体集B中的零个或多个实体相关联，但实体集B中的每个实体最多与实体集A中的一个实体相关联。 1 2 3 +-----+ 1:N +-----+ | A |-------------| B | +-----+ +-----+ 多对多 (M:N)： 实体集A中的每个实体可以与实体集B中的零个或多个实体相关联，并且实体集B中的每个实体也可以与实体集A中的零个或多个实体相关联。 1 2 3 +-----+ M:N +-----+ | A |-------------| B | +-----+ +-----+ 表示方法： 将基数比率标注在连接联系和实体的直线上。通常在靠近实体的一侧标注该实体参与联系的最小和最大实例数。例如： 1:1 1:N 或 (0,N) 或 (1,N) M:N 或 (0,M, 0,N) 或 (1,M, 1,N) 2.5 联系的属性 联系本身也可以拥有属性，这些属性描述了实体之间联系的特征。例如，学生选修课程的联系可以有“选修日期”和“成绩”等属性。 表示： 联系的属性用椭圆表示，并用虚线连接到所属的联系菱形框。 1 2 3 4 5 6 7 +----------+ +----------+ +----------+ | 学生 |--------| 选修 |--------| 课程 | +----------+ +----------+ +----------+ | +----------+ | 成绩 | +----------+ 注意： 只有在多对多联系中，联系才通常拥有自己的属性。在一对一或一对多联系中，联系的属性通常可以转移到参与联系的某个实体中。 2.6 弱实体 (Weak Entity) 定义： 依赖于另一个实体 (称为强实体或标识实体) 而存在的实体，自身没有主键。弱实体通过与强实体的联系以及自身的局部键来唯一标识。 表示： 用双层矩形框表示。 标识性联系 (Identifying Relationship)： 弱实体与强实体之间的联系，用于标识弱实体实例。用双层菱形框表示。 1 2 3 4 5 6 7 8 9 +------------+ +--------------------+ +----------+ || 家属 ||------|| 属于 (标识性) ||------| 员工 | +------------+ +--------------------+ +----------+ / | \\ / | \\ +-------+ +-------+ | 姓名 | | 关系 | +-------+ +-------+ ------- (局部键) 在上面的例子中，“家属”是弱实体，它依赖于“员工”实体存在，自身的“姓名”不足以唯一标识一个家属，需要结合其所属的员工才能唯一确定。 3. E-R图的绘制步骤 识别实体： 从需求描述中找出所有重要的名词，它们通常代表实体。 识别属性： 为每个实体确定其相关的特征属性。确定主键、候选键、复合属性、多值属性和派生属性。 识别联系： 找出实体之间的动词或动词短语，它们通常代表实体之间的联系。 确定联系的类型和基数比率： 分析每个联系所涉及的实体数量关系 (一对一、一对多、多对多)。 为联系添加属性 (如果需要)： 如果联系本身具有需要记录的信息，则为其添加属性。 绘制E-R图： 使用标准的E-R图符号将实体、属性和联系连接起来。 完善E-R图： 检查E-R图是否准确、完整地反映了数据需求。考虑是否存在冗余或不清晰的地方。 4. E-R模型的优点 简单直观，易于理解和沟通。 独立于具体的数据库实现。 为数据库设计提供了一个清晰的概念框架。 有助于发现和解决数据设计中的问题。 5. E-R模型的局限性 对于复杂的约束和规则，E-R模型可能难以清晰表达。 缺乏形式化的定义，可能存在二义性。 不直接支持数据操作的描述。 6. 总结 E-R模型是数据库设计的重要工具，通过实体、属性和联系的概念，能够有效地描述现实世界的数据及其关系。掌握E-R模型的基本概念和绘制方法，对于进行良好的数据库设计至关重要。在实际应用中，通常会使用专门的建模工具来辅助E-R图的绘制和管理。\n","date":"2025-05-14T13:20:57+08:00","permalink":"https://gavin-gwj.github.io/hugo-dev/p/%E5%AE%9E%E4%BD%93-%E8%81%94%E7%B3%BB%E6%A8%A1%E5%9E%8B-entity-relationship-model-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"实体-联系模型 (Entity-Relationship Model) 学习笔记"},{"content":"2025年5月13日 星期二 晴/多云 📖 学术日常 今天难得没课，终于能专心肝计算机法律大作业了！\n高效输出：两小时极限操作写完5000字，手速堪比代码编译 查重迷惑：Turnitin查重率**0.8%**低到离谱（导师：你这怕不是法外狂徒？） 紧急补救：立刻补了段硬核文献综述： 📜 新增文献支撑\n参照Lessig《代码即法律》的架构理论，结合欧盟《人工智能法案》第17条\u0026quot;高风险系统透明度要求\u0026quot;，对算法解释权条款进行交叉论证\u0026hellip;\n明日待办：明天用知网再战，求求重复率升到5%左右吧🙏 💻 技术历险记 下午作死用Hugo+Github重构博客，结果：\n主题暴雷：下载的hugo-theme-stack居然不兼容最新版，疯狂报错failed to extract shortcode 部署鬼畜：Github Actions自动部署时.md文件全部乱码，被迫手动改编码格式 终极对决：晚上9点才搞定，发现baseURL少写个斜杠导致CSS全崩（人类为什么要发明斜杠？） 🌃 深夜碎碎念 今日成就解锁： ✔️ 法律作业初稿+1\n✔️ Hugo技能点+1（代价是头发-10086）\n明天一定要\u0026hellip;先备份再改代码！（flag高高立起）\n","date":"2025-05-12T00:00:00Z","permalink":"https://gavin-gwj.github.io/hugo-dev/p/5%E6%9C%8813%E6%97%A5%E6%97%A5%E8%AE%B0/","title":"5月13日日记"}]